<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDK动态代理]]></title>
    <url>%2F2019%2F10%2F12%2Fjdk%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[JDK动态代理 整个JDK动态代理的秘密也就这些，简单一句话，动态代理就是要生成一个包装类对象，由于代理的对象是动态的，所以叫动态代理。由于我们需要增强，这个增强是需要留给开发人员开发代码的，因此代理类不能直接包含被代理对象，而是一个InvocationHandler，该InvocationHandler包含被代理对象，并负责分发请求给被代理对象，分发前后均可以做增强。从原理可以看出，JDK动态代理是“对象”的代理。 版权声明：本文为CSDN博主「探索者一号」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/flyfeifei66/article/details/81481222 123456789101112131415161718192021222324interface TargetInterface &#123; String method1(); void method2(); int method3(int x);&#125;class Target implements TargetInterface&#123; @Override public String method1() &#123; System.out.println("method1 running..."); return "aaa"; &#125; @Override public void method2() &#123; System.out.println("method2 running..."); &#125; @Override public int method3(int x) &#123; return x; &#125;&#125; 1234567891011121314151617public class Main &#123; public static void main(String[] args) throws Exception &#123; Target target = new Target(); TargetInterface newProxyInstance = (TargetInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), // new InvocationHandler 重新invoke方法 (proxy, method, argss)-&gt;&#123; System.out.println("before");Object invoke = method.invoke(target, argss);System.out.println("after"); return invoke;&#125;); String method1 = newProxyInstance.method1(); newProxyInstance.method2(); int method3 = newProxyInstance.method3(100); System.out.println(method1); System.out.println(method3); &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统基础知识总结]]></title>
    <url>%2F2019%2F07%2F01%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[操作系统基础知识总结摘自：https://blog.csdn.net/justloveyou_/article/details/78304294 1. 进程和线程区别 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 拥有资源：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 包含关系：没有线程的进程可以看做是单线程的（凡是进程必须有并且至少有一个线程），如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 https://blog.csdn.net/kuangsonghan/article/details/80674777 2. 什么是死锁？死锁产生的条件在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。 2.1 死锁产生的四个必要条件 互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止； 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有； 非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系 2.2 死锁的处理基本策略和常用方法解决死锁的基本方法主要有 预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等。 2.2.1 死锁预防只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生 打破互斥条件：由资源本身属性决定，无实际意义。 打破占有并等待条件：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。 打破非抢占条件：允许进程强行从占有者哪里夺取某些资源。也就是说，但一个进程占有了一部分资源，在其申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。这种预防死锁的方式实现起来困难，会降低系统性能。 打破循环等待条件：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。 2.2.2 死锁避免死锁避免的基本思想是动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。 2.2.3 死锁解除死锁解除的常用两种方法为进程终止和资源抢占。 3. 线程同步 临界区：临界区对象和互斥对象非常相似，只是互斥量允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。 信号量：它允许同一时刻多个线程访问公共资源，但是要控制同一时刻访问的最大线程数量。 事件（信号）：通过通知操作保持多线程同步，还能实现多线程优先级比较。 4. 进程通信 管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信； 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生 消息队列：是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等； 信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段； 套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。 5. 进程有哪几种状态 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源； 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数； 阻塞状态：进程等待某种条件，在条件满足之前无法执行； 6. 线程有哪几种状态在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态。 7. 分页和分段有什么区别（内存管理）段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片） 页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。 区别 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息； 大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定； 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间； 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制； 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。 8. 操作系统中进程调度策略有哪几种 FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化 时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。 多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。 多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CopyOnWriteArrayList和CopyOnWriteArraySet的源码解析]]></title>
    <url>%2F2019%2F06%2F27%2FCopyOnWriteArrayList%E5%92%8CCopyOnWriteArraySet%2F</url>
    <content type="text"><![CDATA[CopyOnWriteArrayList 是一个线程安全的 ArrayList，通过内部的 volatile 数组和显式锁 ReentrantLock 来实现线程安全。而 CopyOnWriteArraySet 是线程安全的 Set，它是由 CopyOnWriteArrayList 实现，内部持有一个 CopyOnWriteArrayList 引用，所有的操作都是由 CopyOnWriteArrayList 来实现的。 和 ArrayList 或 Set 相比，CopyOnWriteArrayList / CopyOnWriteArraySet 拥有以下特性： 适合元素比较少，并且读取操作高于更新(add/set/remove)操作的场景 由于每次更新需要复制内部数组，所以更新操作开销比较大 内部的迭代器 iterator 使用了“快照”技术，存储了内部数组快照， 所以它的 iterator 不支持remove、set、add操作，但是通过迭代器进行并发读取时效率很高。 源码解析12345//锁final transient ReentrantLock lock = new ReentrantLock();//用于存储元素的内部数组private transient volatile Object[] array; CopyOnWriteArrayList 实现非常简单。内部使用了一个 volatile 数组(array)来存储数据，保证了多线程环境下的可见性。在更新数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给 array。正由于这个原因，涉及到数据更新的操作效率很低。 add操作1234567891011121314151617181920212223242526272829303132public void add(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+len); Object[] newElements; //计算偏移量 int numMoved = len - index; if (numMoved == 0) //作为add(E)处理 newElements = Arrays.copyOf(elements, len + 1); else &#123; newElements = new Object[len + 1]; //调用native方法根据index拷贝原数组的前半段 System.arraycopy(elements, 0, newElements, 0, index); //拷贝后半段 System.arraycopy(elements, index, newElements, index + 1, numMoved); &#125; newElements[index] = element; setArray(newElements); &#125; finally &#123; lock.unlock(); &#125;&#125;//System中arrayCopy的实现public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见基础知识汇总]]></title>
    <url>%2F2019%2F06%2F25%2FJava%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Java常见基础知识汇总1. sleep()与wait()区别 锁：sleep()方法正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！)；wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。 使用的位置：sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用； 属于的类：sleep()是线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态； 2. HashSet和TreeSet的区别 实现方式：HashSet是采用hash表来实现的；TreeSet是采用树结构实现(红黑树算法)。 排列顺序：HashSet无序；TreeSet支持两种排序方式，自然排序和定制排序（实现comparable接口）。 复杂度：HashSet方法都是复杂度为O(1)；TreeSet方法都是复杂度为O(log (n))的方法。 判断方法：HashSet判断通过equals方法比较相等，并且两个对象的hashCode()方法返回值相等（需要重写hashCode（）和equals()方法）；TreeSet通过equals方法返回，或者通过CompareTo方法比较； 实现接口：HashSet实现Set接口；TreeSet实现SortedSet接口，SortedSet实现Set接口。 备注：LinkedHashSet介于HashSet和TreeSet之间。它也是一个hash表，但是同时维护了一个双链表来记录插入的顺序。基本方法的复杂度为O(1)。 3. int和Integer的区别1. 区别概述 数据类型：Integer是int的包装类，int则是java的一种基本数据类型； 使用方法：Integer变量必须实例化后才能使用，而int变量不需要； 默认值：Integer 是类，默认值为null，int是基本数据类型，默认值为0； 实质：Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值。 2. 自动装箱和自动拆箱、缓存自动拆箱和自动装箱是 JDK1.5 以后才有的功能，也就是java当中众多的语法糖之一，它的执行是在编译期，会根据代码的语法，在生成class文件的时候，决定是否进行拆箱和装箱动作。 1. 自动装箱对于 1Integer a = 128; 生成class文件时， 1Integer a = Integer.valueOf(128); 2. 自动拆箱将 Integer 类表示的数据赋值给基本数据类型int，就执行了自动拆箱。 12Integer a = new Integer(128);int m = a; class文件： 12Integer a = new Integer(128);int m = a.intValue(); 简单来讲：自动装箱就是Integer.valueOf(int i)；自动拆箱就是 i.intValue()； 3. 缓存 当Integer b1 = 12时，是在常量池中开辟出同一个空间来存储12，在常量池中就必须对其的大小范围做出一个规定，规定其范围为：（-128~127）之间。如果超出了范围，会从堆区new一个Integer对象来存放值。 3. ==的比较1. Integer与Integer由于Integer变量实际上是对一个Integer对象的引用，是对象的地址，所以两个通过new生成的Integer变量永远是不相等的。 123Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false 2. Integer与intInteger与int比较时，会触发自动拆箱，实际为两个int的比较，因此，结果为true。 123Integer i = new Integer(100);int j = 100;System.out.print(i == j); //true 3. 非new生成的Integer变量和new Integer()生成的变量因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同，结果为false。 123Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false 4. 对于两个非new生成的Integer对象如果在缓存范围之内，是指向同一个常量池中的地址，所以是true；如果在缓存范围之外，会new一个对象，内存地址不同，所以为false。 123Integer i = 100;Integer j = 100;System.out.print(i == j); //true 123Integer i = 128;Integer j = 128;System.out.print(i == j); //false 5. 算术运算由于 a+b包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法）,==比较符又将左边的自动拆箱，因此它们比较的是数值是否相等。 equals()会先触发自动装箱，equals 运算符不会进行类型转换，Long.equals(Integer)，结果将是false。 12345Integer a = 1;Integer b = 2;Integer c = 3;System.out.println(c == (a + b)); //trueSystem.out.println(c.equals((a+b))); //true 4. 常量池中的StringJava中的常量池，实际上分为两种形态：静态常量池和运行时常量池。 1. 静态常量池即.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。这种常量池主要用于存放两大类常量：字面量(Literal)和*符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量： 类和接口的全限定名 字段名称和描述符 方法名称和描述符 2. 运行时常量池是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 3. String类的intern()String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。 4. 实例比较12345678910111213141516String s1 = "Hello";String s2 = "Hello";String s3 = "Hel" + "lo";String s4 = "Hel" + new String("lo");String s5 = new String("Hello");String s6 = s5.intern();String s7 = "H";String s8 = "ello";String s9 = s7 + s8; System.out.println(s1 == s2); // trueSystem.out.println(s1 == s3); // trueSystem.out.println(s1 == s4); // falseSystem.out.println(s1 == s9); // falseSystem.out.println(s4 == s5); // falseSystem.out.println(s1 == s6); // true 首先说明一点，在java 中，直接使用==操作符，比较的是两个字符串的引用地址，并不是比较内容，比较内容请用String.equals()。 s1 == s2这个非常好理解，s1、s2在赋值时，均使用的字符串字面量，说白话点，就是直接把字符串写死，在编译期间，这种字面量会直接放入class文件的常量池中，从而实现复用，载入运行时常量池后，s1、s2指向的是同一个内存地址，所以相等。 s1 == s3这个地方有个坑，s3虽然是动态拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此String s3 = “Hel” + “lo”;在class文件中被优化成String s3 = “Hello”，所以s1 == s3成立。只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。 s1 == s4当然不相等，s4虽然也是拼接出来的，但new String(“lo”)这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果，结合字符串不变定理，鬼知道s4被分配到哪去了，所以地址肯定不同。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。 s1 == s9也不相等，道理差不多，虽然s7、s8在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，不能在编译期被确定，所以不做优化，只能等到运行时，在堆中创建s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同。 s4 == s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。 s1 == s6这两个相等完全归功于intern方法，s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等。 12345678910111213public static final String A = "ab"; // 常量Apublic static final String B = "cd"; // 常量Bpublic static void main(String[] args) &#123; String s = A + B; // 将两个常量用+连接对s进行初始化 String t = "abcd"; if (s == t) &#123; System.out.println("s等于t，它们是同一个对象"); &#125; else &#123; System.out.println("s不等于t，它们不是同一个对象"); &#125; &#125; // s等于t，它们是同一个对象// A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了。也就是说：String s=A+B; 等同于：String s="ab"+"cd"; 123456789101112131415161718public static final String A; // 常量Apublic static final String B; // 常量Bstatic &#123; A = "ab"; B = "cd"; &#125; public static void main(String[] args) &#123; // 将两个常量用+连接对s进行初始化 String s = A + B; String t = "abcd"; if (s == t) &#123; System.out.println("s等于t，它们是同一个对象"); &#125; else &#123; System.out.println("s不等于t，它们不是同一个对象"); &#125; &#125; // s不等于t，它们不是同一个对象// A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。 5. 总结 必须要关注编译期的行为，才能更好的理解常量池。 运行时常量池中的常量，基本来源于各个class文件中的常量池。 程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。 6. String、StringBuffer 、StringBuilder 可变性：String 不可变；StringBuffer 和 StringBuilder 可变 线程安全：String 不可变，因此是线程安全的；StringBuilder 不是线程安全的；StringBuffer 是线程安全的，内部使用 synchronized 进行同步。 5.static加载顺序、执行时机1. static代码块执行时机一个类的运行分为以下步骤： 装载 连接 初始化 装载阶段又三个基本动作组成： 通过类型的完全限定名，产生一个代表该类型的二进制数据流 解析这个二进制数据流为方法区内的内部数据结 构创建一个表示该类型的java.lang.Class类的实例 连接阶段又分为三部分： 验证，确认类型符合Java语言的语义，检查各个类之间的二进制兼容性(比如final的类不用拥有子类等)，另外还需要进行符号引用的验证。 准备，Java虚拟机为类变量分配内存，设置默认初始值。 解析(可选的) ，在类型的常量池中寻找类，接口，字段和方法的符号引用，把这些符号引用替换成直接引用的过程。 当一个类被主动使用时，Java虚拟就会对其初始化，如下六种情况为主动使用： 当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等） 当调用某个类的静态方法时 当使用某个类或接口的静态字段时 当调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时 当初始化某个子类时 当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类） Java编译器会收集所有的类变量初始化语句和类型的静态初始化器，将这些放到一个特殊的方法中：clinit。 2. 带有static的代码执行顺序1. 如果类还没有被加载 先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。 执行子类的静态代码块和静态变量初始化。 执行父类的实例变量初始化 执行父类的构造函数 执行子类的实例变量初始化 执行子类的构造函数 2. 如果类已经被加载则静态代码块和静态变量就不用重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。 3. 实例1234567891011121314151617181920212223242526272829public class Test extends Base&#123; static&#123; System.out.println("test static"); &#125; public Test()&#123; System.out.println("test constructor"); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; class Base&#123; static&#123; System.out.println("base static"); &#125; public Base()&#123; System.out.println("base constructor"); &#125;&#125;// base static// test static// base constructor// test constructor 12345678910111213141516171819202122232425262728293031323334353637class Person&#123; static&#123; System.out.println("person static"); &#125; public Person(String str) &#123; System.out.println("person "+str); &#125;&#125;class MyClass extends main &#123; Person person = new Person("MyClass"); static&#123; System.out.println("myclass static"); &#125; public MyClass() &#123; System.out.println("myclass constructor"); &#125;&#125;public class main &#123; Person person = new Person("main"); static&#123; System.out.println("main static"); &#125; public main()&#123; System.out.println("main constructor"); &#125; public static void main(String[] args) &#123; new MyClass(); &#125;&#125;// main static// myclass static// person static// person main// main constructor// person MyClass// myclass constructor 6. 基本数据类型和引用类型在JVM中存储在哪1. 在方法中声明的变量即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因。 在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。 当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在JAVA虚拟机栈中； 当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在JAVA虚拟机的栈中，该变量所指向的对象是放在堆类存中的。 2. 在类中声明的变量成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。 同样在类中声明的变量即可是基本类型的变量，也可是引用类型的变量。 当声明的是基本类型的变量其变量名及其值放在堆内存中的； 引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中。 7. Java 与 C++ 的区别 Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。 Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。 Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。 Java 支持自动垃圾回收，而 C++ 需要手动回收。 Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。 Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。 Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。 Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。 8. 线程池https://www.nowcoder.com/discuss/152050?type=0&amp;order=0&amp;pos=6&amp;page=0]]></content>
      <categories>
        <category>面试</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7安装Nginx]]></title>
    <url>%2F2019%2F06%2F25%2Fcentos7%E5%AE%89%E8%A3%85nginx%2F</url>
    <content type="text"><![CDATA[CentOS7安裝Nginx1. 下載nginx安裝包wget 官網下載地址 2.解壓編譯安裝tar -zxvf nginx-***.tar.gz ./configure --prefix=/usr/local/nginx（必须先建好目录） 此時可能會出現錯誤 ./configure: error: the HTTP rewrite module requires the PCRE library. ./configure: error: the HTTP cache module requires md5 functions 2.1 安裝pcre-develyum -y install pcre-devel 2.2 安裝openssl openssl-develyum -y install openssl openssl-devel 3. make、make installmake make install 4. 防火墻開啟對應端口firewall-cmd --zone=public --add-port=80/tcp --permanent firewall-cmd --reload 为nginx添加SSL支持模块使用proxy_pass https://XXXXXXXXX时，遇到问题 nginx https protocol requires SSL support in /usr/local/nginx/conf/nginx.conf 原因：在当初编译安装时，没有加--with-http_ssl_module参数。 解决办法：重新编译源码包。 关闭nginx，切到源码包目录 12./configure --prefix= /usr/local/nginx --with-http_ssl_modulemake 注意，此时千万不能手快直接 make install！ 12cp /usr/local/nginx/sbin/nginx ~/cp objs /nginx /usr/local/nginx/sbin/ 其中，objs/nginx 是新编译出来的nginx可执行程序。覆盖之后，再尝试重新启动nginx，就没有问题了。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS和concurrent.atomic]]></title>
    <url>%2F2019%2F06%2F21%2FCAS%E5%92%8Cconcurrent.atomic%2F</url>
    <content type="text"><![CDATA[CAS和concurrent.atomichttps://www.jianshu.com/p/a897c4b8929f https://blog.csdn.net/javazejian/article/details/72772470 CASCAS,compare and swap比较并替换。 CAS有三个参数：需要读写的内存位值（V）、进行比较的预期原值（A）和拟写入的新值(B)。当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。 CAS是一项乐观的技术，它希望能成功地执行更新操作，并且如果有另一个线程在最近一次检查后更新了该变量，那么CAS能检测到这个错误。当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都将失败。但是，失败的线程并不会被挂起（这就是与获取锁的机制不同之处），而是被告知在这次竞争中失败，并可以多次尝试。这种灵活性就大大减少了与锁相关的活跃性风险。 并发包中的原子操作类(Atomic系列)原子更新基本类型主要包括3个类： AtomicBoolean：原子更新布尔类型 AtomicInteger：原子更新整型 AtomicLong：原子更新长整型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // 获取指针类Unsafe private static final Unsafe unsafe = Unsafe.getUnsafe(); //下述变量value在AtomicInteger实例对象内的内存偏移量 private static final long valueOffset; static &#123; try &#123; //通过unsafe类的objectFieldOffset()方法，获取value变量在对象内存中的偏移 //通过该偏移量valueOffset，unsafe类的内部方法可以获取到变量value对其进行取值或赋值操作 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; //当前AtomicInteger封装的int变量value private volatile int value; public AtomicInteger(int initialValue) &#123; value = initialValue; &#125; public AtomicInteger() &#123; &#125; //获取当前最新值， public final int get() &#123; return value; &#125; //设置当前值，具备volatile效果，方法用final修饰是为了更进一步的保证线程安全。 public final void set(int newValue) &#123; value = newValue; &#125; //最终会设置成newValue，使用该方法后可能导致其他线程在之后的一小段时间内可以获取到旧值，有点类似于延迟加载 public final void lazySet(int newValue) &#123; unsafe.putOrderedInt(this, valueOffset, newValue); &#125; //设置新值并获取旧值，底层调用的是CAS操作即unsafe.compareAndSwapInt()方法 public final int getAndSet(int newValue) &#123; return unsafe.getAndSetInt(this, valueOffset, newValue); &#125; //如果当前值为expect，则设置为update(当前值指的是value变量) public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; //当前值加1返回旧值，底层CAS操作 public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125; //当前值减1，返回旧值，底层CAS操作 public final int getAndDecrement() &#123; return unsafe.getAndAddInt(this, valueOffset, -1); &#125; //当前值增加delta，返回旧值，底层CAS操作 public final int getAndAdd(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta); &#125; //当前值加1，返回新值，底层CAS操作 public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1; &#125; //当前值减1，返回新值，底层CAS操作 public final int decrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, -1) - 1; &#125; //当前值增加delta，返回新值，底层CAS操作 public final int addAndGet(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta) + delta; &#125; //省略一些不常用的方法....&#125; 通过上述的分析，可以发现AtomicInteger原子类的内部几乎是基于前面分析过Unsafe类中的CAS相关操作的方法实现的，这也同时证明AtomicInteger是基于无锁实现的，这里重点分析自增操作实现过程，其他方法自增实现原理一样。 我们发现AtomicInteger类中所有自增或自减的方法都间接调用Unsafe类中的getAndAddInt()方法实现了CAS操作，从而保证了线程安全，关于getAndAddInt其实前面已分析过，它是Unsafe类中1.8新增的方法，源码如下 12345678//Unsafe类中的getAndAddInt方法public final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v; &#125; ​]]></content>
      <categories>
        <category>面试</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap和HashMap部分源码解读]]></title>
    <url>%2F2019%2F06%2F20%2FConcurrentHashMap%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap1. put方法https://www.jianshu.com/p/0fb89aefac66 检查key/value是否为空，如果为空，抛出异常。 进入for死循环 table是否为null，如果为空，initTable，然后2 根据hash，计算出索引，取到该索引的节点f 检查f是否为空，如果为空，直接new一个新节点，并CAS插入，退出循环 如果f不空，检查f.hash == MOVED(-1)，如果相等，帮助扩容 如果f.hash != MOVED(-1)，synchronized该节点 如果链表中找到值为key的节点，更新节点的value；如果没有，new节点，增加到尾部 如果节点数&gt;8，treeifyBin转换红黑树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public V put(K key, V value) &#123; return putVal(key, value, false);&#125;/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); //计算hash值 int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123;//自旋 //f:索引节点; n:tab.length; i:新节点索引 (n - 1) &amp; hash; fh:f.hash Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) //初始化 tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;//索引i节点为空，直接插入 //cas插入节点,成功则跳出循环 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; //当前节点处于移动状态-其他线程正在进行节点转移操作 else if ((fh = f.hash) == MOVED) //帮助转移 tab = helpTransfer(tab, f); else &#123; V oldVal = null; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123;//check stable //f.hash&gt;=0,说明f是链表的头结点 if (fh &gt;= 0) &#123; binCount = 1;//记录链表节点数，用于后面是否转换为红黑树做判断 for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; //key相同 修改 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; //到这里说明已经是链表尾，把当前值作为新的节点插入到队尾 if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; //红黑树节点操作 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; //如果链表中节点数binCount &gt;= TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构 if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; //更新新元素个数 addCount(1L, binCount); return null;&#125; 2. 扩容transferhttps://www.jianshu.com/p/2829fe36a8dd 计算转移幅度stride（或者说是当前线程需要转移的节点数），最小为16； 创建一个相当于当前 table 两倍容量的 Node 数组nextTab，转移完成后用作新的 table ； 从transferIndex（初始为table.length，也就是 table 的最后一个节点）开始，依次向前处理stride个节点。用i作为索引控制流程。如果table[i]为空，用fwd占位，如果为fwd，跳过。如果table[i]是正常节点，用算法将链表/红黑树节点分割成两份，nextTab中生成索引为i和i+n的节点。 最后把操作过的节点都设为 ForwardingNode 节点（hash= MOVED，这样别的线程就可以检测到） 再来看看源码和注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/** * Moves and/or copies the nodes in each bin to new table. See * above for explanation. * * transferIndex 表示转移时的下标，初始为扩容前的 length。 * * 我们假设长度是 32 */private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; // 转移幅度( tab.length/(NCPU*8) )，最小为16 if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range 细分范围 stridea：TODO // 新的 table 尚未初始化 if (nextTab == null) &#123; // initiating try &#123; // 扩容 2 倍 Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; // 更新 nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME // 扩容失败， sizeCtl 使用 int 最大值。 sizeCtl = Integer.MAX_VALUE; return;// 结束 &#125; // 更新成员变量 nextTable = nextTab; // 更新转移下标，就是 老的 tab 的 length transferIndex = n; &#125; // 新 tab 的 length int nextn = nextTab.length; // 创建一个 fwd 节点，用于占位。当别的线程发现这个槽位中是 fwd 类型的节点，则跳过这个节点。 ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); // 首次推进为 true，如果等于 true，说明需要再次推进一个下标（i--），反之，如果是 false，那么就不能推进下标，需要将当前的下标处理完毕才能继续推进 boolean advance = true; // 完成状态，如果是 true，就结束此方法。 boolean finishing = false; // to ensure sweep before committing nextTab // i：当前处理的Node索引；bound：需要处理节点的索引边界 for (int i = 0, bound = 0;;) &#123; // f:当前处理i位置的node; fh:f.hash Node&lt;K,V&gt; f; int fh; // 如果当前线程可以向后推进；这个循环就是控制 i 递减。同时，每个线程都会进入这里取得自己需要转移的桶的区间 while (advance) &#123; //nextIndex:下一个要处理的节点索引; nextBound:下一个需要处理的节点的索引边界 int nextIndex, nextBound; // 通过while循环获取本次需要移动的节点索引i // 通常，第一次进入循环，i-- 这个判断会无法通过，从而走下面的 nextIndex 赋值操作（获取最新的转移下标）。其余情况都是：如果可以推进，将 i 减一，然后修改成不可推进。如果 i 对应的桶处理成功了，改成可以推进。 if (--i &gt;= bound || finishing) advance = false; // 节点已全部转移。 else if ((nextIndex = transferIndex) &lt;= 0) &#123; // 如果小于等于0，说明没有区间了 ，i 改成 -1，推进状态变成 false，不再推进，表示，扩容结束了，当前线程可以退出了 // 这个 -1 会在下面的 if 块里判断，从而进入完成状态判断 i = -1; advance = false;// 这里设置 false，是为了防止在没有成功处理一个桶的情况下却进行了推进 &#125; //transferIndex（初值为最后一个节点的索引），表示从transferIndex开始后面所有的节点都已分配， //每次线程领取扩容任务后，需要更新transferIndex的值(transferIndex-stride)。 //CAS修改transferIndex，即 length - 区间值，留下剩余的区间值供后面的线程使用 else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound;// 这个值就是当前线程可以处理的最小当前区间最小下标 i = nextIndex - 1; // 初次对i 赋值，这个就是当前线程可以处理的当前区间的最大下标 advance = false; &#125; &#125;// 如果 i 小于0 （不在 tab 下标内，按照上面的判断，领取最后一段区间的线程扩容结束） // 如果 i &gt;= tab.length(不知道为什么这么判断) // 如果 i + tab.length &gt;= nextTable.length （不知道为什么这么判断） if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; if (finishing) &#123; // 如果完成了扩容 nextTable = null;// 删除成员变量 table = nextTab;// 更新 table sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); // 更新阈值 return;// 结束方法。 &#125; //当前线程已经完成转移，但可能还有其他线程正在进行转移操作 //每个线程完成自己的扩容操作后就对sizeCtl-1 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;// 尝试将 sc -1. 表示这个线程结束帮助扩容了，将 sc 的低 16 位减一。 if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)// 如果 sc - 2 不等于标识符左移 16 位。不相等，说明这里还有其他线程正在操作，直接返回。 return; //如果还有其他线程正在操作，直接返回，否则的话重新初始化i对原tab进行一遍检查然后再提交 finishing = advance = true;// 如果相等，扩容结束了，更新 finising 变量 i = n; // 再次循环检查一下整张表 &#125; &#125; else if ((f = tabAt(tab, i)) == null) // 获取老 tab i 下标位置的变量，如果是 null，就使用 fwd 占位。 advance = casTabAt(tab, i, null, fwd);// 如果成功写入 fwd 占位，再次推进一个下标 else if ((fh = f.hash) == MOVED)// 如果不是 null 且 hash 值是 MOVED。 advance = true; // already processed // 说明别的线程已经处理过了，再次推进一个下标 else &#123;// 到这里，说明这个位置有实际值了，且不是占位符。对这个节点上锁。为什么上锁，防止 putVal 的时候向链表插入数据 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; Node&lt;K,V&gt; ln, hn;//处理当前拿到的节点,构建两个node:ln/hn。ln:原位置; hn:i+n位置 // 如果 f 的 hash 值大于 0 。TreeBin 的 hash 是 -2 if (fh &gt;= 0) &#123;//当前为链表节点（fh&gt;=0） // 对老长度进行与运算, 把原链表中的元素分成两份 // 由于 Map 的长度都是 2 的次方（000001000 这类的数字），那么取于 length 只有 2 种结果，一种是 0，一种是1 // 如果是结果是0 ，Doug Lea 将其放在低位，反之放在高位，目的是将链表重新 hash，放到对应的位置上，使新的索引为i+n或i不变 int runBit = fh &amp; n; //最后一个与头节点f索引不同的节点 Node&lt;K,V&gt; lastRun = f; //从索引i的节点开始向后查找最后一个有效节点 for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; if (b != runBit) &#123; runBit = b; // 更新 runBit，用于下面判断 lastRun 该赋值给 ln 还是 hn。 lastRun = p; // 这个 lastRun 保证后面的节点与自己的取于值相同，避免后面没有必要的循环 &#125; &#125; if (runBit == 0) &#123;// 如果最后更新的 runBit 是 0 ，索引为i不变 ln = lastRun; hn = null; &#125; else &#123; hn = lastRun; // 如果最后更新的 runBit 是 1，新的索引为i+n ln = null; &#125;// 再次循环，生成两个链表，lastRun 作为停止条件，这样就是避免无谓的循环（lastRun 后面都是相同的取于结果） for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; // 如果与运算结果是 0，那么就还在低位 if ((ph &amp; n) == 0) // 如果是0 ，那么创建低位节点 ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else // 1 则创建高位 hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; // 其实这里类似 hashMap // 设置低位链表放在新链表的 i setTabAt(nextTab, i, ln); // 设置高位链表，在原有长度上加 n setTabAt(nextTab, i + n, hn); // 将旧的链表设置成占位符 setTabAt(tab, i, fwd); // 继续向后推进 advance = true; &#125;// 如果是红黑树 else if (f instanceof TreeBin) &#123; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; // 遍历 for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); // 和链表相同的判断，与运算 == 0 的放在原位置 if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; // 不是 0 的放在i+n else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; // 如果树的节点数小于等于 6，那么转成链表，反之，创建一个新的树 ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; // 低位树 setTabAt(nextTab, i, ln); // 高位数 setTabAt(nextTab, i + n, hn); // 旧的设置成占位符 setTabAt(tab, i, fwd); // 继续向后推进 advance = true; &#125; &#125; &#125; &#125; &#125;&#125; 3. helpTransfer方法如果索引到的节点的 hash 为-1，说明当前节点处于移动状态（或者说是其他线程正在对 f 节点进行转移操作。这里主要是靠 ForwardingNode 节点来检测，因为ForwardingNode 中有指向nextTable的指针，可以得到nextTable。这个线程就可以先去帮助扩容。 123456789101112131415161718192021//帮助其他线程进行转移操作final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123; //计算操作栈校验码 int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)//不需要帮助转移，跳出 break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;//CAS更新帮助转移的线程数 transfer(tab, nextTab); break; &#125; &#125; return nextTab; &#125; return table;&#125; HashMap底层数据结构数组+链表+红黑树 1. 初始化时tableSizeFor方法找到大于或等于 cap 的最小2的幂的数作为table的size。 123456789101112/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 2. 查找(n - 1)&amp; hash相当于取这个数的二进制的n-1位，得到的就是映射到table的位置索引。 hash : 1011 1001 n-1: 0000 1111 (n - 1)&amp; hash :0000 1001 12345678910111213141516171819202122232425final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // first索引到的table的节点 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node // 如果first的key就是要查找的key，直接返回这个节点 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 如果不是，并且还有next的节点，继续查找 if ((e = first.next) != null) &#123; // 如果 first 是 TreeNode 类型，则调用黑红树查找方法 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 对链表进行查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 3. 遍历用Iterator迭代器遍历，不多赘述。遍历顺序是先数组，数组中有链表/红黑树时，遍历它们。所以插入顺序和遍历顺序会不一致。 4. 插入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 如果table还未被初始化，先初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 如果table[i]没有节点，新生成一个节点 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 如果键的值以及节点 hash 等于链表中的第一个键值对节点时，则将 e 指向该键值对 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 如果桶中的引用类型为 TreeNode，则调用红黑树的插入方法 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 对链表进行遍历，并统计链表长度 for (int binCount = 0; ; ++binCount) &#123; // 链表中不包含要插入的键值对节点时，则将该节点接在链表的最后 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 如果链表长度大于或等于树化阈值，则进行树化操作 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 条件为 true，表示当前链表包含要插入的键值对，终止遍历 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 判断要插入的键值对是否存在 HashMap 中 if (e != null) &#123; // existing mapping for key V oldValue = e.value; // onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 键值对数量超过阈值时，则进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 5. 扩容 计算新桶数组的容量 newCap 和新阈值 newThr 根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的 将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; // 如果 table 不为空，表明已经初始化过了 if (oldCap &gt; 0) &#123; // 当 table 容量超过容量最大值，则不再扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 按旧容量和阈值的2倍计算新容量和阈值的大小 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold /* * 初始化时，将 threshold 的值赋值给 newCap， * HashMap 使用 threshold 变量暂时保存 initialCapacity 参数的值 */ newCap = oldThr; else &#123; // zero initial threshold signifies using defaults /* * 调用无参构造方法时，桶数组容量为默认容量， * 阈值为默认容量与默认负载因子乘积 */ newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // newThr 为 0 时，按阈值计算公式进行计算 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; // 创建新的桶数组，桶数组的初始化也是在这里完成的 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) // 重新映射时，需要对红黑树进行拆分 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; // 遍历链表，并将链表节点按原顺序进行分组 do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 将分组后的链表映射到新桶中 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 6. 链表树化、红黑树链化与拆分6.1 键值比较HashMap 是做了三步处理，确保可以比较出两个键的大小，如下： 比较键与键之间 hash 的大小，如果 hash 相同，继续往下比较 检测键类是否实现了 Comparable 接口，如果实现调用 compareTo 方法进行比较 如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 tieBreakOrder（大家自己看源码吧） 6.2 红黑树拆分扩容后，普通节点需要重新映射，红黑树节点也不例外。按照一般的思路，我们可以先把红黑树转成链表，之后再重新映射链表即可。这种处理方式是大家比较容易想到的，但这样做会损失一定的效率。不同于上面的处理方式，HashMap 实现的思路则是上好佳（上好佳请把广告费打给我）。如上节所说，在将普通链表转成红黑树时，HashMap 通过两个额外的引用 next 和 prev 保留了原链表的节点顺序。这样再对红黑树进行重新映射时，完全可以按照映射链表的方式进行。这样就避免了将红黑树转成链表后再进行映射，无形中提高了效率。 6.3 红黑树链化前面说过，红黑树中仍然保留了原链表节点顺序。有了这个前提，再将红黑树转成链表就简单多了，仅需将 TreeNode 链表转成 Node 类型的链表即可。 7. transient如果大家细心阅读 HashMap 的源码，会发现桶数组 table 被申明为 transient。transient 表示易变的意思，在 Java 中，被该关键字修饰的变量不会被默认的序列化机制序列化。我们再回到源码中，考虑一个问题：桶数组 table 是 HashMap 底层重要的数据结构，不序列化的话，别人还怎么还原呢？ 这里简单说明一下吧，HashMap 并没有使用默认的序列化机制，而是通过实现readObject/writeObject两个方法自定义了序列化的内容。这样做是有原因的，试问一句，HashMap 中存储的内容是什么？不用说，大家也知道是键值对。所以只要我们把键值对序列化了，我们就可以根据键值对数据重建 HashMap。有的朋友可能会想，序列化 table 不是可以一步到位，后面直接还原不就行了吗？这样一想，倒也是合理。但序列化 talbe 存在着两个问题： table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间 同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误。 以上两个问题中，第一个问题比较好理解，第二个问题解释一下。HashMap 的get/put/remove等方法第一步就是根据 hash 找到键所在的桶位置，但如果键没有覆写 hashCode 方法，计算 hash 时最终调用 Object 中的 hashCode 方法。但 Object 中的 hashCode 方法是 native 型的，不同的 JVM 下，可能会有不同的实现，产生的 hash 可能也是不一样的。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题。 综上所述，大家应该能明白 HashMap 不序列化 table 的原因了。]]></content>
      <categories>
        <category>面试</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReentrantLock(重入锁)的源码解析]]></title>
    <url>%2F2019%2F06%2F13%2FReentrantLock-%E9%87%8D%E5%85%A5%E9%94%81-%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[转自：从源码角度彻底理解ReentrantLock(重入锁)](https://www.cnblogs.com/takumicx/p/9402021.html)) 1. 类继承关系公平锁内部是FairSync,非公平锁内部是NonfairSync。而不管是FairSync还是NonfariSync,都间接继承自AbstractQueuedSynchronizer这个抽象类，如下图所示 2. 非公平锁加锁流程加锁流程从lock.lock()开始 123public void lock() &#123; sync.lock();&#125; 1. 加锁流程真正意义上的入口123456789101112/** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. *///加锁流程真正意义上的入口final void lock() &#123; //以cas方式尝试将AQS中的state从0更新为1 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread());//获取锁成功则将当前线程标记为持有锁的线程,然后直接返回 else acquire(1);//获取锁失败则执行该方法&#125; 首先尝试快速获取锁,以cas的方式将state的值更新为1,只有当state的原值为0时更新才能成功,因为state在ReentrantLock的语境下等同于锁被线程重入的次数,这意味着只有当前锁未被任何线程持有时该动作才会返回成功。若获取锁成功,则将当前线程标记为持有锁的线程,然后整个加锁流程就结束了。若获取锁失败,则执行acquire方法 1234567891011121314151617/** * Acquires in exclusive mode, ignoring interrupts. Implemented * by invoking at least once &#123;@link #tryAcquire&#125;, * returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking &#123;@link * #tryAcquire&#125; until success. This method can be used * to implement method &#123;@link Lock#lock&#125;. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and * can represent anything you like. */public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 该方法主要的逻辑都在if判断条件中,这里面有3个重要的方法tryAcquire()，addWaiter()和acquireQueued()，这三个方法中分别封装了加锁流程中的主要处理逻辑，理解了这三个方法到底做了哪些事情，整个加锁流程就清晰了。 2. 尝试获取锁的通用方法:tryAcquire()tryAcquire是AQS中定义的钩子方法,如下所示 123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 该方法默认会抛出异常,强制同步组件通过扩展AQS来实现同步功能的时候必须重写该方法,ReentrantLock在公平和非公平模式下对此有不同实现,非公平模式的实现如下： 123protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125; 底层调用了nonfairTryAcquire()从方法名上我们就可以知道这是非公平模式下尝试获取锁的方法,具体方法实现如下 12345678910111213141516171819202122/** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread();//获取当前线程实例 int c = getState();//获取state变量的值,即当前锁被重入的次数 if (c == 0) &#123; //state为0,说明当前锁未被任何线程持有 if (compareAndSetState(0, acquires)) &#123; //以cas方式获取锁 setExclusiveOwnerThread(current); //将当前线程标记为持有锁的线程 return true;//获取锁成功,非重入 &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; //当前线程就是持有锁的线程,说明该锁被重入了 int nextc = c + acquires;//计算state变量要更新的值 if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc);//非同步方式更新state值 return true; //获取锁成功,重入 &#125; return false; //走到这里说明尝试获取锁失败&#125; 这是非公平模式下获取锁的通用方法。它囊括了当前线程在尝试获取锁时的所有可能情况： 1.当前锁未被任何线程持有(state=0),则以cas方式获取锁,若获取成功则设置exclusiveOwnerThread为当前线程,然后返回成功的结果；若cas失败,说明在得到state=0和cas获取锁之间有其他线程已经获取了锁,返回失败结果。 2.若锁已经被当前线程获取(state&gt;0,exclusiveOwnerThread为当前线程),则将锁的重入次数加1(state+1),然后返回成功结果。因为该线程之前已经获得了锁,所以这个累加操作不用同步。 3.若当前锁已经被其他线程持有(state&gt;0,exclusiveOwnerThread不为当前线程),则直接返回失败结果 因为我们用state来统计锁被线程重入的次数,所以当前线程尝试获取锁的操作是否成功可以简化为:state值是否成功累加1,是则尝试获取锁成功,否则尝试获取锁失败。 其实这里还可以思考一个问题:nonfairTryAcquire已经实现了一个囊括所有可能情况的尝试获取锁的方式,为何在刚进入lock方法时还要通过compareAndSetState(0, 1)去获取锁,毕竟后者只有在锁未被任何线程持有时才能执行成功,我们完全可以把compareAndSetState(0, 1)去掉,对最后的结果不会有任何影响。这种在进行通用逻辑处理之前针对某些特殊情况提前进行处理的方式在后面还会看到,一个直观的想法就是它能提升性能，而代价是牺牲一定的代码简洁性。 退回到上层的acquire方法, 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; //当前线程尝试获取锁,若获取成功返回true,否则false acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //只有当前线程获取锁失败才会执行者这部分代码 selfInterrupt();&#125; tryAcquire(arg)返回成功,则说明当前线程成功获取了锁(第一次获取或者重入),由取反和&amp;&amp;可知,整个流程到这结束，只有当前线程获取锁失败才会执行后面的判断。先来看addWaiter(Node.EXCLUSIVE)部分,这部分代码描述了当线程获取锁失败时如何安全的加入同步等待队列。这部分代码可以说是整个加锁流程源码的精华,充分体现了并发编程的艺术性。 3. 获取锁失败的线程如何安全的加入同步队列:addWaiter()这部分逻辑在addWaiter()方法中 1234567891011121314151617181920/** * Creates and enqueues node for current thread and given mode. * * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node */private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode);//首先创建一个新节点,并将当前线程实例封装在内部,mode这里为null // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node);//入队的逻辑这里都有 return node;&#125; 首先创建了一个新节点,并将当前线程实例封装在其内部,之后我们直接看enq(node)方法就可以了,中间这部分逻辑在enq(node)中都有,之所以加上这部分“重复代码”和尝试获取锁时的“重复代码”一样,对某些特殊情况进行提前处理,牺牲一定的代码可读性换取性能提升。 1234567891011121314151617181920/** * Inserts node into queue, initializing if necessary. See picture above. * @param node the node to insert * @return node's predecessor */private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail;//t指向当前队列的最后一个节点,队列为空则为null if (t == null) &#123; // Must initialize //队列为空 if (compareAndSetHead(new Node())) //构造新结点,CAS方式设置为队列首元素,当head==null时更新成功 tail = head;//尾指针指向首结点 &#125; else &#123; //队列不为空 node.prev = t; if (compareAndSetTail(t, node)) &#123; //CAS将尾指针指向当前结点,当t(原来的尾指针)==tail(当前真实的尾指针)时执行成功 t.next = node; //原尾结点的next指针指向当前结点 return t; &#125; &#125; &#125;&#125; 这里有两个CAS操作: compareAndSetHead(new Node()),CAS方式更新head指针,仅当原值为null时更新成功 123456/** * CAS head field. Used only by enq. */private final boolean compareAndSetHead(Node update) &#123; return unsafe.compareAndSwapObject(this, headOffset, null, update);&#125; compareAndSetTail(t, node),CAS方式更新tial指针,仅当原值为t时更新成功 123456/** * CAS tail field. Used only by enq. */private final boolean compareAndSetTail(Node expect, Node update) &#123; return unsafe.compareAndSwapObject(this, tailOffset, expect, update);&#125; 外层的for循环保证了所有获取锁失败的线程经过失败重试后最后都能加入同步队列。因为AQS的同步队列是不带哨兵结点的,故当队列为空时要进行特殊处理,这部分在if分句中。注意当前线程所在的结点不能直接插入空队列,因为阻塞的线程是由前驱结点进行唤醒的。故先要插入一个结点作为队列首元素,当锁释放时由它来唤醒后面被阻塞的线程,从逻辑上这个队列首元素也可以表示当前正获取锁的线程,虽然并不一定真实持有其线程实例。 首先通过new Node()创建一个空结点，然后以CAS方式让头指针指向该结点(该结点并非当前线程所在的结点),若该操作成功,则将尾指针也指向该结点。这部分的操作流程可以用下图表示 当队列不为空,则执行通用的入队逻辑,这部分在else分句中 1234567else &#123; node.prev = t;//step1:待插入结点pre指针指向原尾结点 if (compareAndSetTail(t, node)) &#123; step2:CAS方式更改尾指针 t.next = node; //原尾结点next指针指向新的结点 return t; &#125; &#125; 首先当前线程所在的结点的前向指针pre指向当前线程认为的尾结点,源码中用t表示。然后以CAS的方式将尾指针指向当前结点,该操作仅当tail=t,即尾指针在进行CAS前未改变时成功。若CAS执行成功,则将原尾结点的后向指针next指向新的尾结点。 到这为止,获取锁失败的线程加入同步队列的逻辑就结束了。但是线程加入同步队列后会做什么我们并不清楚,这部分在acquireQueued方法中。 4. 线程加入同步队列后会做什么:acquireQueued()先看acquireQueued方法的源码 1234567891011121314151617181920212223242526272829303132/** * Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire. * * @param node the node * @param arg the acquire argument * @return &#123;@code true&#125; if interrupted while waiting */final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; //死循环,正常情况下线程只有获得锁才能跳出循环 for (;;) &#123; final Node p = node.predecessor();//获得当前线程所在结点的前驱结点 //第一个if分句 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); //将当前结点设置为队列头结点 p.next = null; // help GC failed = false; return interrupted;//正常情况下死循环唯一的出口 &#125; //第二个if分句 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //判断是否要阻塞当前线程 parkAndCheckInterrupt()) //阻塞当前线程 interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 这段代码主要的内容都在for循环中,这是一个死循环,主要有两个if分句构成。第一个if分句中,当前线程首先会判断前驱结点是否是头结点,如果是则尝试获取锁,获取锁成功则会设置当前结点为头结点(更新头指针)。为什么必须前驱结点为头结点才尝试去获取锁？因为头结点表示当前正占有锁的线程,正常情况下该线程释放锁后会通知后面结点中阻塞的线程,阻塞线程被唤醒后去获取锁,这是我们希望看到的。然而还有一种情况,就是前驱结点取消了等待,此时当前线程也会被唤醒,这时候就不应该去获取锁,而是往前回溯一直找到一个没有取消等待的结点,然后将自身连接在它后面。一旦我们成功获取了锁并成功将自身设置为头结点,就会跳出for循环。否则就会执行第二个if分句:确保前驱结点的状态为SIGNAL,然后阻塞当前线程。 先来看shouldParkAfterFailedAcquire(p, node)，从方法名上我们可以大概猜出这是判断是否要阻塞当前线程的,方法内容如下 12345678910111213141516171819202122232425262728293031323334353637/** * Checks and updates status for a node that failed to acquire. * Returns true if thread should block. This is the main signal * control in all acquire loops. Requires that pred == node.prev. * * @param pred node's predecessor holding status * @param node the node * @return &#123;@code true&#125; if thread should block */private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) //状态为SIGNAL /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) &#123; //状态为CANCELLED, /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; //状态为初始化状态(ReentrentLock语境下) /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 可以看到针对前驱结点pred的状态会进行不同的处理 1.pred状态为SIGNAL,则返回true,表示要阻塞当前线程。 2.pred状态为CANCELLED,则一直往队列头部回溯直到找到一个状态不为CANCELLED的结点,将当前节点node挂在这个结点的后面。 3.pred的状态为初始化状态,此时通过compareAndSetWaitStatus(pred, ws, Node.SIGNAL)方法将pred的状态改为SIGNAL。 其实这个方法的含义很简单,就是确保当前结点的前驱结点的状态为SIGNAL,SIGNAL意味着线程释放锁后会唤醒后面阻塞的线程。毕竟,只有确保能够被唤醒，当前线程才能放心的阻塞。 但是要注意只有在前驱结点已经是SIGNAL状态后才会执行后面的方法立即阻塞,对应上面的第一种情况。其他两种情况则因为返回false而重新执行一遍for循环。这种延迟阻塞其实也是一种高并发场景下的优化,试想我如果在重新执行循环的时候成功获取了锁,是不是线程阻塞唤醒的开销就省了呢？ 最后我们来看看阻塞线程的方法parkAndCheckInterrupt shouldParkAfterFailedAcquire返回true表示应该阻塞当前线程,则会执行parkAndCheckInterrupt方法,这个方法比较简单,底层调用了LockSupport来阻塞当前线程,源码如下: 123456789/** * Convenience method to park and then check if interrupted * * @return &#123;@code true&#125; if interrupted */private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 该方法内部通过调用LockSupport的park方法来阻塞当前线程,不清楚LockSupport的可以看看这里。LockSupport功能简介及原理浅析 下面通过一张流程图来说明线程从加入同步队列到成功获取锁的过程 概括的说,线程在同步队列中会尝试获取锁,失败则被阻塞,被唤醒后会不停的重复这个过程,直到线程真正持有了锁,并将自身结点置于队列头部。 5. ReentrantLock非公平模式下的加锁流程 3. 非公平模式解锁流程解锁的源码相对简单,源码如下： 12345678910111213public void unlock() &#123; sync.release(1); &#125;public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; //释放锁(state-1),若释放后锁可被其他线程获取(state=0),返回true Node h = head; //当前队列不为空且头结点状态不为初始化状态(0) if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); //唤醒同步队列中被阻塞的线程 return true; &#125; return false;&#125; 正确找到sync的实现类,找到真正的入口方法,主要内容都在一个if语句中,先看下判断条件tryRelease方法 123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; //计算待更新的state值 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; //待更新的state值为0,说明持有锁的线程未重入,一旦释放锁其他线程将能获取 free = true; setExclusiveOwnerThread(null);//清除锁的持有线程标记 &#125; setState(c);//更新state值 return free;&#125; tryRelease其实只是将线程持有锁的次数减1,即将state值减1,若减少后线程将完全释放锁(state值为0),则该方法将返回true,否则返回false。由于执行该方法的线程必然持有锁,故该方法不需要任何同步操作。若当前线程已经完全释放锁,即锁可被其他线程使用,则还应该唤醒后续等待线程。不过在此之前需要进行两个条件的判断： h!=null是为了防止队列为空,即没有任何线程处于等待队列中,那么也就不需要进行唤醒的操作 h.waitStatus != 0是为了防止队列中虽有线程,但该线程还未阻塞,由前面的分析知,线程在阻塞自己前必须设置前驱结点的状态为SIGNAL,否则它不会阻塞自己。 接下来就是唤醒线程的操作,unparkSuccessor(h)源码如下 1234567891011121314151617181920212223242526private void unparkSuccessor(Node node) &#123; /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 一般情况下只要唤醒后继结点的线程就行了,但是后继结点可能已经取消等待,所以从队列尾部往前回溯,找到离头结点最近的正常结点,并唤醒其线程。 流程图 4. 公平锁模式公平锁模式下,对锁的获取有严格的条件限制。在同步队列有线程等待的情况下,所有线程在获取锁前必须先加入同步队列。队列中的线程按加入队列的先后次序获得锁。从公平锁加锁的入口开始 123final void lock()&#123; acquire(1);&#125; 对比非公平锁,少了非重入式获取锁的方法,这是第一个不同点 接着看获取锁的通用方法tryAcquire(),该方法在线程未进入队列,加入队列阻塞前和阻塞后被唤醒时都会执行。 在真正CAS获取锁之前加了判断,内容如下 12345678910public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 从方法名我们就可知道这是判断队列中是否有优先级更高的等待线程,队列中哪个线程优先级最高？由于头结点是当前获取锁的线程,队列中的第二个结点代表的线程优先级最高。那么我们只要判断队列中第二个结点是否存在以及这个结点是否代表当前线程就行了。这里分了两种情况进行探讨: 第二个结点已经完全插入,但是这个结点是否就是当前线程所在结点还未知,所以通过s.thread != Thread.currentThread()进行判断,如果为true,说明第二个结点代表其他线程。 第二个结点并未完全插入,我们知道结点入队一共分三步： 1.待插入结点的pre指针指向原尾结点 2.CAS更新尾指针 3.原尾结点的next指针指向新插入结点 所以(s = h.next) == null 就是用来判断2刚执行成功但还未执行3这种情况的。这种情况第二个结点必然属于其他线程。以上两种情况都会使该方法返回true,即当前有优先级更高的线程在队列中等待,那么当前线程将不会执行CAS操作去获取锁,保证了线程获取锁的顺序与加入同步队列的顺序一致，很好的保证了公平性,但也增加了获取锁的成本。 5. 为什么基于FIFO的同步队列可以实现非公平锁？由FIFO队列的特性知,先加入同步队列等待的线程会比后加入的线程更靠近队列的头部,那么它将比后者更早的被唤醒,它也就能更早的得到锁。从这个意义上,对于在同步队列中等待的线程而言,它们获得锁的顺序和加入同步队列的顺序一致，这显然是一种公平模式。然而,线程并非只有在加入队列后才有机会获得锁,哪怕同步队列中已有线程在等待,非公平锁的不公平之处就在于此。回看下非公平锁的加锁流程,线程在进入同步队列等待之前有两次抢占锁的机会: 第一次是非重入式的获取锁,只有在当前锁未被任何线程占有(包括自身)时才能成功; 第二次是在进入同步队列前,包含所有情况的获取锁的方式。 只有这两次获取锁都失败后,线程才会构造结点并加入同步队列等待。而线程释放锁时是先释放锁(修改state值),然后才唤醒后继结点的线程的。试想下这种情况,线程A已经释放锁,但还没来得及唤醒后继线程C,而这时另一个线程B刚好尝试获取锁,此时锁恰好不被任何线程持有,它将成功获取锁而不用加入队列等待。线程C被唤醒尝试获取锁,而此时锁已经被线程B抢占,故而其获取失败并继续在队列中等待。整个过程如下图所示 如果以线程第一次尝试获取锁到最后成功获取锁的次序来看,非公平锁确实很不公平。因为在队列中等待很久的线程相比还未进入队列等待的线程并没有优先权,甚至竞争也处于劣势:在队列中的线程要等待其他线程唤醒,在获取锁之前还要检查前驱结点是否为头结点。在锁竞争激烈的情况下,在队列中等待的线程可能迟迟竞争不到锁。这也就非公平在高并发情况下会出现的饥饿问题。那我们再开发中为什么大多使用会导致饥饿的非公平锁？很简单,因为它性能好啊。 6. 为什么非公平锁性能好非公平锁对锁的竞争是抢占式的(队列中线程除外),线程在进入等待队列前可以进行两次尝试,这大大增加了获取锁的机会。这种好处体现在两个方面: 1.线程不必加入等待队列就可以获得锁,不仅免去了构造结点并加入队列的繁琐操作,同时也节省了线程阻塞唤醒的开销,线程阻塞和唤醒涉及到线程上下文的切换和操作系统的系统调用,是非常耗时的。在高并发情况下,如果线程持有锁的时间非常短,短到线程入队阻塞的过程超过线程持有并释放锁的时间开销,那么这种抢占式特性对并发性能的提升会更加明显。 2.减少CAS竞争。如果线程必须要加入阻塞队列才能获取锁,那入队时CAS竞争将变得异常激烈,CAS操作虽然不会导致失败线程挂起,但不断失败重试导致的对CPU的浪费也不能忽视。除此之外,加锁流程中至少有两处通过将某些特殊情况提前来减少CAS操作的竞争,增加并发情况下的性能。一处就是获取锁时将非重入的情况提前]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列同步器（AQS）]]></title>
    <url>%2F2019%2F05%2F11%2F%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%2F</url>
    <content type="text"><![CDATA[队列同步器（AQS）队列选择器（AbstractQueuedSynchronizer）是用来构建锁或者其他同步组件的基础框架。 同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。 同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。锁是面向使用者的，同步器面向的是锁的实现者。 接口同步器的设计是基于模板方法。使用者继承同步器并重写制定的方法，随后将同步器组合在自定义同步组件的实现中，并调用模板方法，模板方法调用的是使用者重写的方法。 同步器提供3个方法访问和修改同步状态： getState()：获取当前同步状态。 setState(int newState)：设置当前同步状态。 compareAndSetState(int expect, int update)：使用CAS设置。 同步器可重写的方法： protected boolean tryAcquire(int arg)：独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再使用CAS设置同步状态。 protected boolean tryRelease(int arg)：独占式释放同步状态，等待同步状态的线程将有机会获取同步状态。 protected int tryAcquireShared(int arg)：共享式获取同步状态，返回大于等与0的值则表示获取成功，否则获取失败 protected boolean tryReleaseShared(int arg)：共享式释放同步状态。 protected boolean isHeldExclusively()：当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占。 模板方法： public final void acquire(int arg)：独占式获取同步状态，如果当前线程获取同步状态成功，则会返回，否则当前线程会进入同步队列等待，该方法需要调用重写的tryAcquire(int arg)方法 public final void acquireInterruptibly(int arg) throws InterruptedException：独占式获取同步状态，如果当前线程获取同步状态成功，则会返回，否则当前线程会进入同步队列等待，但同时该方法也会响应中断，如果线程在同步队列中被中断，则该方法会抛出InterruptedException并返回。 public final boolean tryAcquireNanos(int arg, long nanosTimeout)throws InterruptedException：在acquireInterruptibly(int arg)增加了超时限制，超时未获得同步状态返回false，否则返回true public final void acquireShared(int arg)：共享式获取同步状态，如果未获取到则进入同步队列等待，与独占式不同的是，共享式可以同时有多个线程获取到同步状态。 public final void acquireSharedInterruptibly(int arg)：共享式获取同步状态，如果当前线程获取同步状态成功，则会返回，否则当前线程会进入同步队列等待，但同时该方法也会响应中断，如果线程在同步队列中被中断，则该方法会抛出InterruptedException并返回。 public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)throws InterruptedException：在acquireSharedInterruptibly(int arg)基础上增加了超时限制，超时未获得同步状态返回false，否则返回true public final boolean release(int arg)：独占式释放同步状态，该方法会在释放同步状态之后，唤醒同步队列中第一个节点中的线程。 public final boolean releaseShared(int arg)：共享式释放同步状态。 public final Collection getQueuedThreads()：获取在同步队列上等待的线程集合。 实现共享式获取与独占式获取 共享式访问资源时，其他共享式的访问均被允许，独占式访问被阻塞。 独占式访问资源时，其他访问均被阻塞。 同步队列同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点并加入队列，同时阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。 节点是构成同步队列的基础，同步器拥有首节点和尾节点，没有成功获取同步状态的线程会将成为节点加入该队列的尾部。 设置尾节点需要CAS方法：compareAndSetTail(Node expect, Node update)。 获取首节点是通过同步成功的线程，所以不需要CAS。 独占式同步状态通过acquire(int arg)可以获取同步状态。主要逻辑： 首先调用自定义同步器实现的tryAcquire(int arg)方法（保证线程安全的获取同步），通过addWaiter(Node node)方法将该节点加入到队列尾部，最后acquireQueued(Node node, int arg)，使得该节点以死循环的方式获取同步状态。 通过release(int arg)方法可以释放同步状态，该方法释放了同步状态后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）。 共享式同步状态通过调用acquireShared(int arg)可以共享式获取同步状态。具体： 调用tryAcquireShared(int arg)尝试获取同步状态，当返回值大于等于0，表示能获取到同步。 doAcquireShared(int arg)自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步，如果返回值大于等于0，表示获取成功并退出自旋。 调用releaseShared(int arg)释放同步状态。和独占式的区别是tryReleaseShared(int arg)必须保证同步状态线程安全释放，一般是通过循环和CAS保证。 独占式超时获取同步通过调用doAcquireNanos(int arg, long nanosTimeout)可以超时获取同步。在支持响应中断的基础上，增加了超时获取的特性。 过程和独占式类似，但在同步获取失败时判断是否超时。 如果没有超时，重新 计算超时间隔，然后使当前线程等待nanosTimeout。 如果nanosTimeout小于等于spinForTimeoutThrehold时，将不会将使该线程进行超时等待，而是进入快速自旋。 参考： 深入学习Lock锁（1）——队列同步器]]></content>
      <categories>
        <category>面试</category>
        <category>Java</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GC相关]]></title>
    <url>%2F2019%2F04%2F16%2FGC%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[GC相关1. 垃圾收集器程序计数器、虚拟机栈、本地方法栈随线程生死，不需要太考虑回收。而Java堆和方法区只有在运行期间才知道创建哪些对象，这部分内存分配和回收都是动态的，GC要关注的是这部分。 引用技术算法：给对象添加一个引用计数器，有引用，+1，引用失效，-1，任何时刻计数器为0的对象不能被使用。但是解决不了对象相互循环引用的问题，故基本不用。 可达性分析算法基本思想：通过一系列的GC Roots对象作为起始点，向下搜索，当一个对象到GC Roots没有任何引用链相连，则这个对象是可回收的。 可以作为GC Roots的对象： 虚拟机栈（本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈JNI（一般指Native方法）引用的对象 4种引用 强引用：“Object obj = new Object()”这类的引用，只要引用存在，GC就不会回收。 软引用：有用但非必需的对象。在系统将要发生内存溢出之前，会把这些对象列进回收范围中进行二次回收。如果仍没有足够内存，才会抛出内存溢出异常。SoftReference类实现。 弱引用：强度比软引用更弱，只能生存到下一次垃圾回收前，当GC工作，无论当前内存是否足够，都会被回收。WeakReference类实现。 虚引用：唯一目的就是能在GC时收到一个系统通知。PhantomReference类实现。 finalize方法 finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。 finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为) 大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。 方法区的回收方法区（永久代）回收主要两方面：废弃常量和无用的类。 判断方法，满足一下3个条件： 该类所有实例都被回收 加载该类的类加载器被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射获得该类的方法。 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景需要回收方法区，保证永久代不溢出。 2. 垃圾收集算法标记-清除算法先标记所有需要回收的对象，标记完成后统一回收所有被标记的对象。 缺点：效率不高；会产生大量不连续的内存碎片。 复制算法把内存划分成大小相同的两块，当一块用完了，将存活的对象复制到另一块内存，然后将使用过的内存一次清理掉。 大部分虚拟机用复制算法回收新生代。将内存分为一块大的Eden，和两块小的Survivor，每次使用Eden和一个Survivor。回收时将Eden和Survivor中存活的对象复制到另一个Survivor上，然后清理。默认Eden和Survivor比例是8:1。当Survivor空间不够时，需要依赖老年代进行分配担保。 标记-整理算法复制收集算法在对象存活率高时效率不高，老年代使用标记-整理算法，标记同标记-清除算法，整理是让所有存活的对象向一段移动，然后清理掉边界以外的内存。 分代收集算法GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。 “分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。 3. 垃圾收集器Serial收集器 串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停） 参数控制：-XX:+UseSerialGC 串行收集器。 ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩 参数控制：-XX:+UseParNewGC ParNew收集器 -XX:ParallelGCThreads 限制线程数量。 Parallel收集器Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩 参数控制：-XX:+UseParallelGC 使用Parallel收集器+ 老年代串行。 Serial Old收集器Serial Old是Serial的老年代版本，单线程，标记-整理算法。 两个用途：与Parallel Scavenge搭配使用；作为CMS收集器的后备预案，发生Concurrent Mode Failure时使用。 Parallel old收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。 参数控制： -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行。 CMS收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew） 优点：并发收集、低停顿缺点：产生大量空间碎片、并发阶段会降低吞吐量 参数控制：-XX:+UseConcMarkSweepGC 使用CMS收集器-XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长-XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后，进行一次碎片整理-XX:ParallelCMSThreads 设定CMS的线程数量（一般情况约等于可用CPU数量） G1收集器详解 JVM Garbage First(G1) 垃圾收集器 G1收集器（Garbage-First）：是当今收集器技术发展的最前沿的成果之一，G1是一款面向服务器端应用的垃圾收集器。 使用G1收集器时，java堆的内存布局就与其他收集器有很大差别，它将整个java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代与老年代的概念，但新生代与老年代不再试物理隔离的了，他们都是一部分Region（不需要连续）的集合。G1具备如下特点： 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能够独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。 空间整合：G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。 可预测停顿：这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 收集步骤： 初始标记 Initial Mark，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark) 根分区扫描 Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。 并发标记 Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。 存活数据计算 Live Data Accounting，存活数据计算(Live Data Accounting)是标记操作的附加产物，只要一个对象被标记，同时会被计算字节数，并计入分区空间。只有NTAMS以下的对象会被标记和计算，在标记周期的最后，Next位图将被清空，等待下次标记周期。 重新标记 Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。 清除 Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。 复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。]]></content>
      <categories>
        <category>面试</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存区域和对象]]></title>
    <url>%2F2019%2F04%2F15%2FJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JVM内存区域和对象1. Java内存区域 1.1 程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。 如果是执行java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果native方法，计数器值为空。 不会发生任何OutOfMemoryError。 1.2 Java虚拟机栈线程私有。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 局部变量表存放了编译器可知的各种基础数据类型（boolean、byte、char、short、int、long、float、double）、对象引用（reference类型，不是对象本身，是一个指向对象起始地址的引用指针，或者是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 如果扩展时无法申请到足够的内存，会抛出OutOfMemoryError异常。 1.3 本地方法栈与虚拟机栈类似，为执行的Native方法服务。 会抛出OutOfMemoryError异常和StackOverflowError异常。 1.4 Java堆Java虚拟机的内存最大的。被所有线程共享。唯一目的是存放对象实例。 Java堆是垃圾收集器管理的主要区域。细分为：新生代、老年代。 如果在堆中没有内存完成实例分配，而且堆无法扩展，会OutOfMemoryError异常。 1.5 方法区线程共享。存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。可以不实现垃圾收集。 当方法区无法满足内存分配需求，OutOfMemoryError异常。 1.6 运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这些内容在类加载时进入该区域。 无法满足内存分配需求，OutOfMemoryError异常。 1.7 直接内存直接内存不是运行时数据区的一部分，但可能导致OutOfMemoryError。 2. JVM中的对象指的是普通对象，不是数据和Class对象。 2.1 对象的创建JVM遇到一个new时，先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查该符号引用代表的类是否被加载、解析和初始化过。如果没有，必须先执行响应的类加载。 类加载后，为新生对象分配内存，分配任务相当于把一块确定大小的内存从Java堆中划分出来。 内存分配完成后，JVM将分配到的内存初始化为零值。 然后，JVM对对象进行必要的设置，如属于哪个类的实例、对象的哈希码、GC分代年龄等信息，存放到对象的对象头。 此时，JVM中的新对象已产生，接着可以执行init方法。我们根据需要进行初始化，生产我们想用的对象。 2.1.1 分配策略由Java堆是否规整决定，是否规整由GC是否带有压缩功能决定。 指针碰撞：规整。由一个指针作为使用和空闲内存的分割指示器。 空闲列表：不规整。维护一个列表记录是否可用。 2.1.2 线程安全解决方案 对分配内存空间的动作做同步处理 使用本地线程分配缓冲 2.2 对象的内存布局分为：对象头、实例数据和对齐填充。 2.2.1 对象头分为两部分。 第一部分用于存储对象自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程特有的锁、偏向线程ID、偏向时间戳等。 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过该指针来确定这个对象是哪个类的实例。 2.2.2 实例数据对象真正存储的有效信息，也是在程序中定义的各种类型的字段内容。 2.2.3 对齐填充不必然存在，没特别意义，只是占位符的作用。 2.3 对象的访问定位程序通过栈上的reference数据来操作栈上的具体对象。访问方式有两种： 句柄：堆中划分出一块内存作为句柄池，reference存储的是对象句柄的地址，句柄中存的是实例数据和类型数据各自的具体地址。 直接指针：堆要存放基础数据相关信息。reference存储的是对象地址。]]></content>
      <categories>
        <category>面试</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库知识整理]]></title>
    <url>%2F2019%2F03%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[数据库相关总结 参考：https://www.weiweiblog.cn/databases/ 1. 范式1. 第一范式每个属性都不可再分。 2. 第二范式消除了非主属性对于码的部分函数依赖。所有非主属性都必须和主键有完全依赖关系，不能存在有某个非主属性只和主键的一部分有关。 12345部分函数依赖：若XY是关系R中的属性，X-&gt;Y，X&apos;是X的子集，若存在X&apos;-&gt;Y，则Y部分函数依赖X。安全函数依赖：若XY是关系R中的属性，X-&gt;Y，X&apos;是X的子集，若每个X&apos;！-&gt;Y，则Y完全函数依赖X。传递函数依赖：在关系R(U)中，XYZ是R的三个属性集合，若X确定Y，Y确定Z，X不包含Y，Y不确定Z，(XUY)∩Z为空，则称Z传递函数依赖于X。 3. 第三范式消除了非主属性对于码的传递函数依赖。不仅要满足第二范式，而且所有属性都要互相独立，没有传递关系。 2. 数据库索引索引通常是由B树或者B+树实现。 2.1. B树和B+树的区别 B树的键和值也存在内部节点和叶子结点中，B+树内部结点只存键，叶子结点存键和值。 B+树的叶子结点有一条链相连。 B树的好处B树在内部存键值，频繁访问的节点在根节点附近可以提高查询效率，如果特定数据是重复读取，B树更好。 B+树的好处一次读取大量数据时，因为B+树内部节点只存键，因此可以读取更多键，又因为叶子节点有链，读取大量数据时不需要每次都遍历内部节点。 2.2. 数据库使用B+还是BB树只适合随机检索，B+树同时适合随机检索和顺序检索。 B+树空间利用率更高，I/O次数少，磁盘读写少。索引也很大，需要以文件的形式存在磁盘中。索引查找就会产生I/O操作。B+树可以一次读取更多的关键字，因此I/O次数少。 B+树查询效率更稳定。B树关键字在内部节点中也有，找到关键字就能确定记录。性能代价相当于二分查找。B+树每次都是跟到叶节点，效率更稳定。 B+树顺序遍历效率也不低。B+树叶子结点有链。 2.3. 索引类型 主键索引：数据列不允许重复，不允许为null，一个表只能有一个主键索引。 唯一索引：数据列不允许重复，允许为null，一个表允许多个列创建唯一索引。 普通索引：没有唯一性限制，可以为空。 全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。 联合索引：可以多个列共同创建联合索引。一个查询可以使用其中一个列，但必须遵守最左前缀原则。 2.4. 聚集索与非聚集索 聚集索引：各行的物理顺序和逻辑顺序相同，一个表只能有一个。 非聚集索引：数据与索引在不同位置，索引中存在指向数据的指针，可以有多个。非聚集索引，分成普通索引，唯一索引，全文索引。 InnoDB的数据文件本身就是索引文件。InnoDB数据文件按聚集索引，所以InnoDB必须有主键。InnoDB聚集索引规则： 如果有主键，主键就是聚集索引。 如果没有主键，第一个唯一非空索引就是聚集索引。 如果1、2都没有，会生成一个隐藏的主键作为聚集索引，它是6个字节的列，随着数据插入自增。 2.5. MyISAM和InnoDB索引实现 索引 MyISAM InnoDB 主键索引 在主键索引中，索引页中存放的是主键和指向数据页的偏移量；数据页中存放的是主键和该主键所属行记录的地址空间。 索引页仍然存放主键和和指向数据页的偏移量，但数据页存放的是完整的记录。也就是在InnoDB中，数据和主键索引是存放在一起的。 辅助索引 在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。综上所述，在MyISAM中，索引文件和数据文件分开存放，不管是主键索引还是辅助索引，都属于非聚集索引。 索引节点存放的内容一样，仍然是键值信息和指向数据页的偏移量；但数据页中存放的是键值信息和该键值对应的主键。然后通过主键查询主键索引就能找到该条记录。 2.6. 索引的优点 创建唯一性索引，可以确保每行数据的唯一性。 提高数据检索效率。 加快表与表之间的连接。 使用分组和排序字句检索时，可以加快检索时间。 通过使用索引，在查询过程中，使用查询优化器，提高系统性能。 2.7. 索引的缺点 时间方面：创建和维护需要时间。对数据增删改也需要对索引维护。 空间方面：索引需要占据物理空间。 2.8. 索引的优化 非空字段：索引的列最好为非空。空值很难优化，用其他方式（0，特殊值等）代替空值。 取离散大的列：将更离散的数据放在联合索引前面。 索引字段越小越好：数据以页为单位存储，一页数据越多，一次IO操作得到的数据越多。 对 where,on,group by,order by 中出现的列使用索引。 对于like查询，%不放在前面。 最左前缀匹配原则。 2.9. 最左前缀匹配原则mysql会向右匹配到范围查询（&lt;,&gt;,between等），=、in放在左边。 = in 可以乱序。 3. 事务事务是一个不可分割的数据库操作序列，是数据库并发操作的基本单位，其结果是从一种一致性状态到另一种一致性状态。 3.1. 四大特性（ACID）原子性（Atomicity）事务是数据库逻辑工作单位，其操作要么全做，要么全不做。 一致性（Consistency）其结果必须是从一种一致性状态到另一种一致性状态。 隔离性（Isolation）一个事务的执行不能被其他事务干扰。 持久性（Duration）持久性表示一旦事务被提交了，数据库的数据改变就是永久性的，即使遇到故障也不会丢失提交的操作。 3.2. 不考虑隔离性会出现的问题 脏读： 一个事务读到了另一个未提交事务的数据。 不可重复读：一个事务两次查询的间隔中，另一个事务修改并提交了数据，导致两次查询结果不同。 幻读：一个事务两次查询中数据笔数不一致。 不可重复读和幻读都是查询中被另一个事务修改并提交了，不同的是不可重复读查询的是同一条数据，幻读是一批数据（比如数据的条数）。 3.3 隔离级别 Read Uncommitted(读未提交)：所有事务都可以看到其他事务未提交的结果。一般很少用。 Read commited(读已提交)：一个事务只能看见已提交的结果。除mysql外大多数数据库默认。 Repeatable Read(可重复读)：确保了同一个事务的多个实例并发读数据时能看到相同的结果。mysql默认。 Serializable(顺序读)：最高的隔离级别，解决了幻读，但会出现大量超时和锁竞争。 事务隔离级别对比 事务隔离级别 脏读 不可重复读 幻读 Read Uncommitted 允许 允许 允许 Read commited 不允许 允许 允许 Repeatable Read 不允许 不允许 允许 Serializable 不允许 不允许 不允许 隔离级别与锁Read Uncommitted：读操作不加S锁。Read commited：读操作加S锁，在语句执行完释放锁。Repeatable Read：读操作加S锁，事务提交后释放锁。Serializable：在Repeatable read的基础上，加范围锁。 3.4. 操作start transaction;开始事务 commit; 提交 rollback; 回滚 4. 其他知识4.1. delete truncate drop区别 区别 delete truncate drop 类型回滚 可回滚 不可回滚 不可回滚 删除内容 表结构还在，删除表全部或部分内容 表结构还在，删除全部内容 删除表，所有数据、索引、权限一并删除 删除速度 逐行删除，速度慢 速度快 速度快 4.2. 存储过程预编译的sql语句，一次创建，多次使用。 优点 预编译，效率高。 存放在数据库，减少网络传输。 安全性高，需要一定权限。 一次创建可多次使用，提高开发效率。 4.3. 视图从一个表或多个表导出的表，是虚表，不存具体数据。 4.4. 主从复制将主数据库的DDL、DML操作记录到二进制文件（BINLOG），传输到从数据库，从数据库重新执行，使得从数据库数据和主数据库保持一致。 主从复制作用 主数据库故障可以切换到从数据库； 可以读写分离； 从数据库可以日志备份。 复制过程 主数据库更新数据完成前，将操作记录顺序记录到BINLOG； 从数据库开启一个I/O线程，该线程在主数据库打开一个普通连接，将读到的事件写入到中继日志，如果读取的进度跟上了master，就进入睡眠等待； 从数据库的SQL线程将读取中继日志，并顺序执行操作。 4.5. 大表数据查询的优化 优化Schema，sql语句、索引。 加缓存，memcached，redis 主从复制，读写分离 垂直拆分，分布式系统 水平切分，要选择合适的sharding key，为了好的查询效率，表结构也要改变，应用也需要改变，sql中尽量带sharding key，将数据定位到限定的表去查，而不是全部的表。 5. MVCC参考：MVCC多版本并发控制浅析 MVCC，多版本并发控制，是mysql数据库InnoDB引擎隔离级别的实现。用于Read Committed和Repeatable Read两种隔离级别。 InnoDB会为每一行添加两个字段，分别表示创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事务的创建不断递增，具体实现： select：满足一下两个条件会返回该行数据：1、 该行的创建版本号小于等于当前版本号，用来确保select操作之前的操作已经执行落地；2、该行的删除版本号大于当前版本号或为空，大于说明当前版本已经有一个并发事务将该行删除了。 insert：将新插入的行的创建版本号设置为当前的系统版本号。 delete：将要删除的行的删除版本号设置为当前的系统版本号。 update：不执行原地操作，还是转化为insert+delete，对旧行执行delete，对新行执行insert。 写操作（update、insert、delete）执行时，将当前的系统版本号递增。 由于旧数据不是真正的删除，所以要对这些数据进行清理，innoDB会开一个后台线程执行，具体规则是将删除版本号小于当前系统版本号的行输出，这个过程叫purge。 MVCC能达到Repeatable Read，但是想达到Serializable还要加锁。 6. 封锁数据库锁 6.1. 封锁粒度MySQL 中提供了两种封锁粒度：行级锁以及表级锁。 在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。 6.2. 封锁类型读写锁 排它锁（Exclusive），简写为 X 锁，又称写锁。 共享锁（Shared），简写为 S 锁，又称读锁。 一个事务对数据对象(数据库、表、页或者行) A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 一个事务对数据对象(数据库、表、页或者行) A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 · X S X × × S × √ 意向锁InnoDB把意向锁设计得比较简练，没有上面定义那么复杂。其意向锁就是表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。由此，意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定： 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁； 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。 事务 T 想要对表 A 加 X 锁时，只需要先检测是否有其它事务在表 A门口加没加 S/X/IX/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 为整张表加 X 锁失败。进入等待。 表级意向锁与表级的X，S的兼容关系如下（IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突）： · X IX S IS X × × × × IX × √ × √ S × × √ √ IS × √ √ √ 6.3. 三级封锁协议保证数据一致性 一级封锁协议事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。 没法解决脏读、不可重复读。 二级封锁协议在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 不可重复读问题还是没有解决。 三级封锁协议在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 6.4. 两段锁协议保证并行调度可串行化 可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。 规定在对任何数据进行读写操作之前，事务首先要获得对该数据的封锁；而且在释放一个封锁之后，事务不再获得任何其他封锁。 就是说加锁和解锁分为两个阶段进行。 6.5. MySQL 隐式与显示锁定MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。 InnoDB 也可以使用特定的语句进行显示锁定： 12SELECT … LOCK In SHARE MODE; SELECT … FOR UPDATE;]]></content>
      <categories>
        <category>面试</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring知识总结整理]]></title>
    <url>%2F2019%2F03%2F29%2FSpring%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Spring面试问题总结整理参考：ssm常见面试题、ssm面试题总结、java ssm框架基础面试题、JavaSSM框架精选50道面试题、69道Spring面试题和答案 spring mvc 简单介绍对springMVC的理解Spring MVC是基于java的实现MVC设计模式的请求驱动类型的轻量级web框架，通过把model、view、controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错。 model负责对应用数据封装，并对外提供应用功能的接口； view负责通过向控制器发送请求，得到响应，并向用户展示处理好的数据； controller负责定义应用的功能，接收用户的动作，并选择响应的view特点： 它是基于组件技术的。全部的应用对象，无论控制器和视图还是业务对象之类的，都是基于java组件，并且和spring基础组件集成。 不依赖于servletAPI（虽然具体具体实现还是依赖servlet） 可以使用任何视图技术，不仅仅jsp 支持各种请求资源的映射策略 它是易于扩展的 spring mvc的流程 用户发送请求到DispatcherServlet； servlet接收到请求后，调用HandlerMapping，请求获取Handler； HandlerMapping根据url得到具体的Handler，生成Handler对象和Handler拦截器，一起返回给DispatcherServlet； DispatcherServlet调用HandlerAdapter； HandlerAdapter执行Handler Handler执行完返回ModerAndView； HandlerAdapter将ModerAndView返回给DispatcherServlet； DispatcherServlet将ModerAndView传给ViewResolver解析； ViewResolver解析后将view返回； DispatcherServlet渲染view（将模型数据填充） 响应用户。 spring mvc优点 可以支持各种视图技术，不仅jsp 与spring框架集成（ioc、aop） 清晰的角色分配：DispatcherServlet、HandlerMapping、HandlerAdapter、ViewResolver. 支持各种请求资源的映射策略。 spring mvc主要组件 DispatcherServlet（不需要程序员开发）：接收请求，响应结果，相当于转发器，有了它可以减少其他组件之间的耦合度。 HandlerMapping（不需要程序员开发）：根据url查找Handler。 HandlerAdapter：根据 Handler 来找到支持它的 HandlerAdapter，通过 HandlerAdapter 执行这个 Handler 得到 ModelAndView 对象。 Handler（需要程序员开发） ViewResolver：进行视图解析，根据视图逻辑名解释成真正的视图。 View（需要开发）：View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等） spring mvc和struts2区别 spring mvc的入口是一个servlet——DispatcherServlet，struts2的入口是一个filter过滤器——StrutsPrepareAndExecuteFilter。 spring mvc是基于方法开发（一个url对应一个方法），请求参数传递到方法的形参，可以是单例也可以是多例；Struts2是基于类开发，传递参数是通过类属性，只能设计为多例。 Struts采用值栈存储请求和响应的数据，通过OGNL存取数据；springmvc通过参数解析器将request请求内容解析，并给方法的形参赋值，将数据和视图封装成ModelAndView对象，最后将ModelAndView的模型数据通过request域传输到页面。jsp视图解析器默认jstl。 springmvc如何设定重定向和转发 转发：返回值前加forward:，如：forward:user.do?name=method4 重定向：返回值前加redirect:，如：redirect:http://www.baidu.com springmvc如何AJAX交互通过jackson框架，可以把java对象转为json。 加入jackson.jar 配置文件中配置json映射 方法前加@ResponseBody 解决POST、GET的中文乱码POST：web.xml中配置CharacterEncodingFilter过滤器，设置成utf-8 GET: 修改tomcat配置文件添加编码与工程编码一致 对参数进行重新编码，String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),”utf-8”) SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。 springmvc常用注解 @RequestMapping：用于处理url映射的注解，用于类或方法上。 @RequestBody：用于实现接收http请求的json数据。 @ResponseBody：用于实现将java对象转化为json对象，返回响应。 SpringMvc中函数的返回值是什么返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的 SpringMvc用什么对象从后台向前台传递数据的通过ModelMap对象，调用put方法，把对象加入，前台用el表达式 ModelMap的数据放入session里面类上加@SessionAttributes注解，里面包含的字符串就是要放入session里的key。 springmvc拦截器两种写法，一种是实现HandlerInterceptor接口，一种是继承适配器类，在接口方法中实现。然后再springmvc的配置文件中配置。 123456789&lt;mvc:interceptors&gt; &lt;!--默认拦截所有--&gt; &lt;bean id='myInterceptor' class='cn.keinz.myHandlerInterceptor'&gt; &lt;!--只针对某个url--&gt; &lt;mvc: interceptor&gt; &lt;mvc: mapping path='/user'/&gt; &lt;bean class='cn.keinz.myHandlerInterceptorAdapter'&gt; &lt;/mvc: interceptor&gt;&lt;/mvc:interceptors&gt; 注解原理JAVA 注解的基本原理 注解本质是继承了Annotation接口的接口，具体的实现类是通过运行时生成的动态 代理类。我们通过反射获取注解时，返回的是java运行时生成的动态代理对象。通过动态代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会通过memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。 Spring为什么要结合使用HandlerMapping以及HandlerAdapter来处理Handler符合面向对象的单一职责原则，代码结构清晰，便于维护，最重要的是可复用性高，如HandlerAdapter可能被用于处理多种Handler。 mybatismybatis的理解 连接数据库通过核心配置文件：SqlMapConfig.xml，配置数据库连接池的获得和连接数据库 操作数据库通过映射配置文件，这个配置文件设计为dao的实现映射，可以视作dao的实现 通过SqlMapConfig.xml构造SqlSessionFactory，由SqlSessionFactory.openSession()获得SqlSession，操作数据库由SqlSession完成。 mybatis底层定义了Executor接口操作数据库，Executor接口有两个实现：一个基本执行器，一个缓存执行器。 Mapped Statement也是mybatis的一个底层封装对象，它包装了mybatis的配置信息和sql映射信息等，mapper.xml的一个sql对应一个Mapped Statement对象，sql的id就是Mapped Statement的id。 Mapped Statement对sql执行的输入参数进行定义，包括HashMap、基本类型和pojo，Executor通过Mapped Statement在执行前将java对象映射到sql中，输入参数映射就是jdbc编程中对prepared statement设置参数。 Mapped Statement对sql执行的输出参数进行定义，包括HashMap、基本类型和pojo，Executor通过Mapped Statement在执行后将输出映射到java对象，输出结果映射相当于jdbc编程中对结果的解析。 mybatis是一个暴露出sql语句的jdbc封装，是一个暴露sql语句的持久层框架，暴露的方式是映射配置文件。 使用MyBatis(IBatis)的好处是什么 mybatis把sql语句从java源程序中独立出来，放在xml里，系统维护更便利。 mybatis封装了底层jdbc api调用细节，并能自动将结果转为java bean对象。 mybatis需要自己编写sql，可以灵活控制sql语句，比hibernate等全自动orm框架有更高的效率，能完成复杂的查询。 对MyBatis的缓存的理解mybatis缓存分为一级缓存和二级缓存，一级缓存在sqlsession中，默认就有，二级缓存基于mapper文件的namespace，开始需要在mybatis-configuration.xml配置文件中添加： 123&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 然后在mapper.xml中： 1&lt;cache type=&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;/&gt; 最后，po类实现serializable接口。 Mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象Mybatis的二级缓存即查询缓存，它的作用域是一个mapper的namespace，即在同一个namespace中查询sql可以从缓存中获取数据。二级缓存是可以跨SqlSession的。 ${} 和 #{}的区别 ${} ：预编译处理，直接把${} 替换成变量的值；$一般用入传入数据库对象，比如数据库表名 #{} ：sql解析时会加上””，当成字符串解析，有效的防止Sql语句注入 order by 动态参数时需要注意，使用${}而不用#{} mybatis一对一的实现方式 联表查询：几个表联合查询，只查询一次，通过resultMap节点配置association节点。 嵌套查询：先查一个表，得到外键id，再到另外的表查询，也是配置association节点，但另外的表查询通过select属性配置。 1&lt;association property=&quot;topicType&quot; select=&quot;selectType&quot; column=&quot;topics_type_id&quot; javaType=&quot;com.tmf.bbs.pojo.Type&quot;/&gt; property：属性名 select：要连接的查询 column：共同列 javaType：集合中元素类型 mybatis一对多的实现方式 联表查询：几个表联合查询，只查询一次，通过resultMap节点配置collection节点。 嵌套查询：先查一个表，得到外键id，再到另外的表查询，也是配置collectionn节点，但另外的表查询通过select属性配置。 1&lt;collection property=&quot;topicComment&quot; column=&quot;id&quot; ofType=&quot;com.tmf.bbs.pojo.Comment&quot; select=&quot;selectComment&quot; /&gt; property：属性名 select：要连接的查询 column：共同列 ofType：集合中元素类型 mybatis的接口绑定，好处mybatis实现了dao接口和xml映射文件的绑定，自动生成了接口的实现，更方便。 接口绑定的实现方式，什么情况下使用注解绑定和xml绑定。sql简单时使用注解绑定。复杂时使用xml绑定。 JDBC与数据库交互的流程是什么 加载数据库驱动 获取数据库连接 生成statement对象 设置sql语句 设置sql参数 使用statement执行sql 获取结果集，解析结果集 关闭连接，释放资源 谈谈对mybatis中的sqlSession、sqlSessionFactoryBuild和sqlSessionFactory的理解。 sqlSession：封装了对数据库操作的方法，是通过sqlSessionFactory创建的 sqlSessionFactory：通过sqlSessionFactoryBuild创建的 sqlSessionFactoryBuild：是创建sqlSessionFactory时使用的，因为sqlSession是由sqlSessionFactory创建，所以可以当做工具类使用 sqlSessionFactory是一个接口，重载了opensession的方法。使用范围是在整个运行范围内，一旦创建可以重复使用，所以可以当做单实例来管理。 sqlSession是面向用户的一个操作数据库的接口，每个线程都有自己的sqlSession，sqlSession不能线程共享，sqlSession不使用就要关闭。 简述Mybatis的插件运行原理Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，还需要在配置文件中配置你编写的插件。 spring如何理解Spring具体来说Spring是一个轻量级的容器，用于管理业务相关对象的。核心功能主要为：IOC,AOP,MVC。 IOC：控制反转，将对象的创建过程交给容器，让容器管理对象的生命周期如创建，初始化，销毁等。 AOP：面向切面编程，对关注点进行模块化，通过对某一功能点进行编程，比如记录日志，有很多个类都需要记录日志的方法，则创建记录日志的代理方法，需要调用该功能是只需要调用代理方法，这就是AOP。 MVC：SpringMvc,Spring提供的基于MVC模式设计的Web框架，如今比较流行的框架之一。 使用Spring框架能带来哪些好处 轻量：Spring 是轻量的，基本的版本大约2MB。 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。 面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。 容器：Spring 包含并管理应用中对象的生命周期和配置。 MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。 什么是控制反转(IOC)？什么是依赖注入 控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。 控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。 依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？ 注入有以下三种实现方式 构造器注入 setter方法注入 接口注入 解释下Spring框架中的IoCIOC:把对象的创建、初始化、销毁交给spring来管理，而不是由开发者控制，实现控制反转。 Spring中的 org.springframework.beans 包和 org.springframework.context包构成了Spring框架IoC容器的基础。 BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。 org.springframework.beans.factory.BeanFactory 是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC 容器的核心接口。 BeanFactory和ApplicationContext有什么区别描述：BeanFactory：是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能；ApplicationContext：应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能： 国际化（MessageSource） 访问资源，如URL和文件（ResourceLoader） 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 消息发送、响应机制（ApplicationEventPublisher） AOP（拦截器） 两者装载bean的区别：BeanFactory：BeanFactory在启动的时候不会去实例化Bean，只有从容器中拿Bean的时候才会去实例化；ApplicationContext：ApplicationContext在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置lazy-init=true来让Bean延迟实例化； 用BeanFactory还是ApplicationContent延迟实例化的优点：（BeanFactory）应用启动的时候占用资源很少；对资源要求较高的应用，比较有优势；不延迟实例化的优点： （ApplicationContext） 所有的Bean在启动的时候都加载，系统运行的速度快； 在启动的时候所有的Bean都加载了，我们就能在系统启动的时候，尽早的发现系统中的配置问题 建议web应用，在启动的时候就把所有的Bean都加载了。（把费时的操作放到系统启动中完成） Spring有几种配置方式 基于xml配置 基于注解配置 基于java配置 如何用基于XML配置的方式配置Spring在Spring框架中，依赖和服务需要在专门的配置文件来实现，常用的XML格式的配置文件。这些配置文件的格式通常用&lt;beans&gt;开头，然后一系列的bean定义和专门的应用配置选项组成。 SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明的方式或基于Java Class的配置方式） Spring的XML配置方式是使用被Spring命名空间的所支持的一系列的XML标签来实现的。Spring有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc和aso。 如何用基于Java配置的方式配置SpringSpring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与 元素类似。被@Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的内部调用@bean方法来设置嵌入bean的依赖关系。 怎样用注解的方式配置SpringSpring在2.5版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代XML方式的bean描述，可以将bean描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在XML注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。 注解装配在Spring中是默认关闭的。所以需要在Spring文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。 1234&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!-- bean definitions go here --&gt; &lt;/beans&gt; 在 标签配置完成以后，就可以用注解的方式在Spring中向属性、方法和构造方法中自动装配变量。 @Required：该注解应用于设值方法。 @Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。 @Qualifier：该注解和@Autowired注解搭配使用，用于消除特定bean自动装配的歧义。 JSR-250 Annotations：Spring支持基于JSR-250 注解的以下注解，@Resource、@PostConstruct 和 @PreDestroy。 什么是Spring BeansSpring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中&lt;bean/&gt; 的形式定义。 Spring 框架定义的beans都是单件beans。在bean tag中有个属性”singleton”，如果它被赋为TRUE，bean 就是单件，否则就是一个 prototype bean。默认是TRUE，所以所有在Spring框架中的beans 缺省都是单件。 请解释Spring Bean的生命周期 实例化bean对象(通过构造方法或者工厂方法) 设置对象属性(setter等)（依赖注入） 如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口） 如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身 将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法 InitializingBean的afterPropertiesSet()，如果实现了该接口，则执行其afterPropertiesSet()方法 调用Bean的初始化方法init-method 将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法 DisposableBean的destroy()，在容器关闭时，如果Bean类实现了该接口，则执行它的destroy()方法 容器关闭之前，调用Bean的销毁方法destroy-method，可以在Bean定义文件中使用destory-method定义的方法 如果使用ApplicationContext来维护一个Bean的生命周期，则基本上与上边的流程相同，只不过在执行BeanNameAware的setBeanName()后，若有Bean类实现了org.springframework.context.ApplicationContextAware接口，则执行其setApplicationContext()方法，然后再进行BeanPostProcessors的processBeforeInitialization()实际上，ApplicationContext除了向BeanFactory那样维护容器外，还提供了更加丰富的框架功能，如Bean的消息，事件处理机制等 Spring支持的几种bean的作用域当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。 singleton : bean在每个Spring ioc 容器中只有一个实例。 prototype：一个bean的定义可以有多个实例。 request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。 session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 哪些是重要的bean生命周期方法？ 你能重载它们吗？有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。 The bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。 什么是Spring的内部bean当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，为了定义inner bean，在Spring 的 基于XML的 配置元数据中，可以在&lt;property/&gt;或 &lt;constructor-arg/&gt; 元素内使用&lt;bean/&gt;元素，内部bean通常是匿名的，它们的Scope一般是prototype。 在 Spring中如何注入一个java集合 &lt;list&gt;类型用于注入一列值，允许有相同的值。 &lt;set&gt;类型用于注入一组值，不允许有相同的值。 &lt;map&gt;类型用于注入一组键值对，键和值都可以为任意类型。 &lt;props&gt;类型用于注入一组键值对，键和值都只能为String类型。 bean装配、bean的自动装配装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。 Spring 容器能够自动装配相互合作的bean，这意味着容器不需要&lt;constructor-arg&gt;和&lt;property&gt;配置，能通过Bean工厂自动处理bean之间的协作。 解释不同方式的自动装配 no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。 byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。 byType:：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。 constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。 autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。 自动装配有哪些局限性 重写： 你仍需用 &lt;constructor-arg&gt;和 &lt;property&gt; 配置来定义依赖，意味着总要重写自动装配。 基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。 模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。 @Required @Autowired @Qualifier 注解 @Required：这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。 @Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。 @Qualifier 注解当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。 介绍一下Spring的事物管理事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。 开发中为了避免这种情况一般都会进行事务管理。Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能。 Spring支持的事务管理类型 编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。 声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。 Spring框架的事务管理有哪些优点 它为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。 它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如 它支持声明式事务管理。 它和Spring各种数据访问抽象层很好得集成。 解释AOPAOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。 在Spring AOP 中，关注点和横切关注的区别是什么 关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。 横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。 连接点、通知、切入点 连接点：代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。 通知：是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。 切入点：是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点 Spring切面可以应用五种类型的通知 before：前置通知，在一个方法执行前被调用。 after: 在方法执行之后调用的通知，无论方法执行是否成功。 after-returning: 仅当方法成功完成后执行的通知。 after-throwing: 在方法抛出异常退出时执行的通知。 around: 在方法执行之前和之后调用的通知。 引入、目标对象、代理 引入：允许我们在已存在的类中增加新的方法和属性。 目标对象：被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）对象。 代理：是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。 有几种不同类型的自动代理 BeanNameAutoProxyCreator DefaultAdvisorAutoProxyCreator Metadata autoproxying 什么是织入。什么是织入应用的不同点织入：把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象。 织入可以在编译时，加载时，或运行时完成。 切面实现 基于XML Schema方式的切面实现：在这种情况下，切面由常规类以及基于XML的配置实现。 基于注解的切面实现：在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。 Spring中用到哪些设计模式 工厂模式（BeanFactory中） 单例模式：Spring中默认bean为单例 适配器模式（HandlerAdater） 装饰者模式 代理模式：在AOP和remoting中被用的比较多，AOP中用到JDK动态代理 观察者模式（listener的实现，例如ApplicationListener） 策略模式（定义一系列的算法，把它们一个个的封装起来，并且使它们可以相互替换。在实例化对象时用到） 模板模式：用来解决代码重复的问题，jdbcTemplate]]></content>
      <categories>
        <category>面试</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[常用设计模式（java）23种常用设计模式的UML类图 1. 创建型1.1 三种工厂模式1. 简单工厂模式参考：java 三种工厂模式 简单工厂模式又 叫静态工厂方法模式（Static FactoryMethod Pattern），是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 代码示例：一个抽象的武器接口： 123public interface ISword&#123; void swordSkill();&#125; 一个具体产品类，武器阐释者： 123456public class ChanShiZhe implements ISword&#123; @Override public void swordSkill()&#123; System.out.println("阐释者——星爆弃疗斩"); &#125;&#125; 另一个具体产品类，武器闪烁之光：123456public class ShanShuoZhiGuang implements ISword&#123; @Override public void swordSkill()&#123; System.out.println("闪烁之光——圣母圣咏"); &#125;&#125; 简单工厂类：123456789101112131415public class SimplySwordFactory&#123; public static final int TYPE_CSZ = 1; public static final int TYPE_SSZG = 2; public static ISword createSword(int type)&#123; switch(type)&#123; case TYPE_CSZ: return new ChanShiZhe(); case TYPE_SSZG: return new ShanShuoZhiGuang(); default: return new ChanShiZhe(); &#125; &#125;&#125; 测试：123456public class SimpleFactoryTest &#123; public static void main(String[] args)&#123; ISword sword = SimplySwordFactory.createSword(SimplySwordFactory.TYPE_CSZ); sword.swordSkill(); &#125;&#125; 总结特点： 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。 create()方法通常是静态的，所以也称之为静态工厂。缺点： 扩展性差（我想增加一种武器，除了新增一个武器产品类，还需要修改工厂类方法） 不同的产品需要不同额外参数的时候 不支持。 2. 工厂方法 提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例。 步骤： 创建抽象工厂类，定义具体工厂的公共接口； 创建抽象产品类 ，定义具体产品的公共接口； 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品； 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法； 外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例 代码示例：工厂接口：123public interface Factory &#123; ISword createSword();&#125; 其实现类（获取具体产品）:123456public class ChanShiZheFactory implements Factory&#123; @Override public ISword createSword()&#123; return new ChanShiZhe(); &#125;&#125; 123456public class ShanShuoZhiGuangFactory implements Factory&#123; @Override public ISword createSword()&#123; return new ShanShuoZhiGuang(); &#125;&#125; 测试：12345678public class FactoryTest &#123; public static void main(String[] args)&#123; ISword csz = new ChanShiZheFactory().createSword(); csz.swordSkill(); ISword sszg = new ShanShuoZhiGuangFactory().createSword(); sszg.swordSkill(); &#125;&#125; 总结优点： 更符合开-闭原则：新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可 符合单一职责原则：每个具体工厂类只负责创建对应的产品 不使用静态工厂方法，可以形成基于继承的等级结构 缺点： 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销； 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类 一个具体工厂只能创建一种具体产品 3. 抽象工厂模式参考：Java设计模式之抽象工厂模式 当每个抽象产品都有多于一个的具体子类的时候（空调有型号A和B两种，发动机也有型号A和B两种），工厂角色怎么知道实例化哪一个子类呢？比如每个抽象产品角色都有两个具体产品（产品空调有两个具体产品空调A和空调B）。抽象工厂模式提供两个具体工厂角色（宝马320系列工厂和宝马230系列工厂），分别对应于这两个具体产品角色，每一个具体工厂角色只负责某一个产品角色的实例化。每一个具体工厂类只负责创建抽象产品的某一个具体子类的实例。 代码示例：产品类： 123456789101112131415161718192021222324252627282930// 武器及型号public interface Sword &#123; void equip();&#125;public class SwordA implements Sword&#123; public void equip()&#123; System.out.println("装备--&gt;双刀"); &#125;&#125;public class SwordB implements Sword&#123; public void equip()&#123; System.out.println("装备--&gt;细剑"); &#125;&#125;//技能及型号public interface Skill &#123; void release();&#125; public class SkillA implements Skill&#123; public void release()&#123; System.out.println("发动--&gt;双刀流"); &#125;&#125;public class SkillB implements Skill&#123; public void release()&#123; System.out.println("发动--&gt;圣母圣咏"); &#125;&#125; 创建工厂类 123456789101112131415161718192021222324252627282930313233//创建工厂的接口 public interface AbstractFactory &#123; //装备武器 public Sword createSword(); //装备技能 public Skill createSkill(); &#125; //为桐人装备 public class Factorykirito implements AbstractFactory&#123; @Override public Sword createSword() &#123; return new SwordA(); &#125; @Override public Skill createSkill() &#123; return new SkillA(); &#125; &#125; //为亚丝娜装备 public class FactoryAsuna implements AbstractFactory &#123; @Override public Sword createSword() &#123; return new SwordB(); &#125; @Override public Skill createSkill() &#123; return new SkillB(); &#125; &#125; 测试类:123456789101112131415public class FactoryTest &#123; public static void main(String[] args)&#123; //生产桐人 Factorykirito factorykirito = new Factorykirito(); System.out.println("这是桐人"); factorykirito.createSword().equip(); factorykirito.createSkill().release(); //生产亚丝娜 FactoryAsuna factoryAsuna = new FactoryAsuna(); System.out.println("这是亚丝娜"); factoryAsuna.createSword().equip(); factoryAsuna.createSkill().release(); &#125;&#125; 控制台输出：123456这是桐人装备--&gt;双刀发动--&gt;双刀流这是亚丝娜装备--&gt;细剑发动--&gt;圣母圣咏 1.2. 七种单例模式参考：Java 单例模式 为什么使用单例： 在内存中只有一个对象，节省内存空间。避免频繁的创建销毁对象，可以提高性能。避免对共享资源的多重占用。可以全局访问。 确保一个类只有一个实例，自行实例化并向系统提供这个实例。 单例需要注意的问题： 线程安全问题 资源使用问题 1. 饿汉式1234567891011public class Singleton&#123; private static Singleton instance = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 优点：未调用getInstance()时，实例已经创建，天生线程安全。 缺点：如果一直没有调用getInstance()，但是实例已经存在，资源浪费。 2. 懒汉式123456789101112public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return intance; &#125;&#125; 优点：方法被调用时才创建实例，节省资源。 缺点：线程不安全。 只有单线程才是单例，多线程可能出现多个单例。 3. synchronized加锁同步123456789101112public class Singleton()&#123; private static Singleton instance; private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 优点：同时满足单线程、多线程。 缺点：性能差。 4. 双重校验12345678910111213141516public class Singleton()&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 优点：同时满足单线程、多线程；性能问题得到优化。 缺点：第一次加载慢，由于java内存模型一些原因偶尔失败。 5. volatile关键字12345678910111213141516public class Singleton&#123; private static volatile instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance = null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; volatile关键字可以解决指令重排。如果没有volatile，两个线程AB，都是第一次调用方法，线程A先执行new，该构造方法是非原子性操作，编译后产生多条字节码指令，由于指令重排，可能会先执行赋值操作，即在内存中开辟空间，然后返回内存的引用，之后instance不再为空，但是实际初始化并未完成，此时线程B进入就会看到不为空但是不完整（初始化未完成）的Singleton对象，所以需要加入volatile关键字，禁止指令重排序优化，从而安全的实现单例。#### 6. 静态内部类静态内部类由JVM来保证线程安全。1234567891011public class Singleton&#123; private Singleton()&#123;&#125; private static class SingletonHolder&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonsHolder.instance; &#125;&#125;- 优点：资源利用率高，不执行getInstance()不被实例，可以执行该类其他静态方法。#### 7. 枚举类实现单例12使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。——Joshua Bloch《effective java》枚举天生线程安全，且可避免反序列化破坏单例。 more detail：为什么我强烈建议大家使用枚举来实现单例12345public enum Singleton&#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 2. 结构型2.1. 适配器模式 场景：结城明日奈想试试双刀流技能（一个类的接口）好不好玩，但是亚丝娜这个账号（客户端所期待的接口）没办法直接用双刀流（接口不匹配的两个类无法一起工作），只能借助适配器。 1. 类适配器参考：Java设计模式之《适配器模式》及应用场景 原理：通过继承来实现适配器功能。 当我们要访问的接口A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，我们又不能改变访问接口A，在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要实现我们访问的接口A，这样我们就能继续访问当前接口A中的方法（虽然它目前不是我们的菜），然后再继承接口B的实现类BB，这样我们可以在适配器P中访问接口B的方法了，这时我们在适配器P中的接口A方法中直接引用BB中的合适方法，这样就完成了一个简单的类适配器。 1234567891011121314151617181920212223242526272829// 亚丝娜账号public interface IAsuna&#123; void login();&#125;// 双刀流public interface IShuangDaoSkil&#123; void releaseSkill();&#125;// 双刀流实现类public class ShuangDaoSkil implements IShuangDaoSkil&#123; @Override public void releaseSkill()&#123; System.out.println("发动双刀流！"); &#125;&#125;// 适配器public class Adapter extends ShuangDaoSkil implements IAsuna&#123; @Override public void login()&#123; releaseSkill(); &#125;&#125;public class client&#123; public static void main(String[] args) &#123; IAsuna asuna = new Adapter(); asuna.login(); &#125;&#125; 2. 对象适配器模式原理：通过组合来实现适配器功能。 当我们要访问的接口A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，我们又不能改变访问接口A，在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要实现我们访问的接口A，这样我们就能继续访问当前接口A中的方法（虽然它目前不是我们的菜），然后在适配器P中定义私有变量C（对象）（B接口指向变量名），再定义一个带参数的构造器用来为对象C赋值，再在A接口的方法实现中使用对象C调用其来源于B接口的方法。 1234567891011121314151617181920212223242526272829303132// 亚丝娜账号public interface IAsuna&#123; void login();&#125;// 双刀流public interface IShuangDaoSkil&#123; void releaseSkill();&#125;// 双刀流实现类public class ShuangDaoSkil implements IShuangDaoSkil&#123; @Override public void releaseSkill()&#123; System.out.println("发动双刀流！"); &#125;&#125;// 适配器public class Adapter implements IAsuna &#123; private ShuangDaoSkil shuangDaoSkill; public Adapter(ShuangDaoSkil shuangDaoSkill)&#123; this.shuangDaoSkill = shuangDaoSkill; &#125; @Override public void login()&#123; shuangDaoSkill.releaseSkill(); &#125;&#125;public class client&#123; public static void main(String[] args) &#123; IAsuna asuna = new Adapter(new ShuangDaoSkil()); asuna.login(); &#125;&#125; 3. 接口适配器模式原理：通过抽象类来实现适配，这种适配稍别于上面所述的适配。 当存在这样一个接口，其中定义了N多的方法，而我们现在却只想使用其中的一个到几个方法，如果我们直接实现接口，那么我们要对所有的方法进行实现，哪怕我们仅仅是对不需要的方法进行置空（只写一对大括号，不做具体方法实现）也会导致这个类变得臃肿，调用也不方便，这时我们可以使用一个抽象类作为中间件，即适配器，用这个抽象类实现接口，而在抽象类中所有的方法都进行置空，那么我们在创建抽象类的继承类，而且重写我们需要使用的那几个方法即可。 12345678910111213141516171819202122232425262728// 目标接口public interface ISkill&#123; void skill1(); void skill2(); void skill3(); void skill4(); void skill5();&#125;// 适配器public abstract Adapter implements ISkill&#123; public void skill1(); public void skill2(); public void skill3(); public void skill4(); public void skill5();&#125;// 适配器实现类public class Skill extends Adapter&#123; public void skill1(); public void skill2();&#125;public class client&#123; public static void main(String[] args) &#123; Skill skill = new Skill; skill.skill1(); skill.skill2(); &#125;&#125; 4. 使用场景类适配器与对象适配器的使用场景一致，仅仅是实现手段稍有区别，二者主要用于如下场景： 想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。 我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。 以上两个场景其实就是从两个角度来描述一类问题，那就是要访问的方法不在合适的接口里，一个从接口出发（被访问），一个从访问出发（主动访问）。 接口适配器使用场景： 想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器。 2.2. 装饰器参考：JAVA装饰器模式、Java设计模式之装饰者模式 Decorator装饰器，顾名思义，就是动态地给一个对象添加一些额外的职责，就好比为房子进行装修一样。因此，装饰器模式具有如下的特征： 它必须具有一个装饰的对象。 它必须拥有与被装饰对象相同的接口。 它可以给被装饰对象添加额外的功能。 用一句话总结就是：保持接口，增强性能。 实际上是基于对象的适配器模式的一种变种。它与对象的适配器模式的异同点如下: 相同点：都拥有一个目标对象。 不同点：适配器模式需要实现另外一个接口，而装饰器模式必须实现该对象的接口。 要实现装饰者模式,注意一下几点内容: 装饰者类要实现真实类同样的接口 装饰者类内有一个真实对象的引用(可以通过装饰者类的构造器传入) 装饰类对象在主类中接受请求,将请求发送给真实的对象(相当于已经将引用传递到了装饰类的真实对象) 装饰者可以在传入真实对象后,增加一些附加功能(因为装饰对象和真实对象都有同样的方法,装饰对象可以添加一定操作在调用真实对象的方法,或者先调用真实对象的方法,再添加自己的方法) 不用继承 来个实例 桐人砍怪： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// 砍怪的接口public interface IKirito&#123; void takeSword(); void releaseSkill(); void getAward(); void operation();&#125;// 正常砍怪的实现类public class Kirito implements IKirito&#123; @Override public void takeSword()&#123; System.out.println("取武器"); &#125; @Override public void releaseSkill()&#123; System.out.println("放技能"); &#125; @Override public void getAward()&#123; System.out.println("捡装备"); &#125; @Override public void operation() &#123; takeSword(); releaseSkill(); getAward(); &#125;&#125;// 定义出需要添加附加功能的抽象类public abstract class AbstractKirito implements IKirito&#123; private IKirito kirito; public AbstractKirito (IKirito kirito)&#123; super(); this.kirito = kirito; &#125; @Override public void takeSword()&#123; this.kirito.takeSword(); &#125; @Override public void releaseSkill()&#123; this.kirito.releaseSkill(); &#125; @Override public void getAward()&#123; this.kirito.getAward(); &#125; @Override public void operation() &#123; takeSword(); releaseSkill(); getAward(); &#125;&#125;// 继承Abstarct类,所以可以有选择的覆盖正常生产馒头的方法,并添加原有方法原来的信息,同时也可以添加自己的方法 //装饰者模式中这里最关键, 对应上述的第1个注意点:装饰者类要实现真实类同样的接口public class WisdomDecorator extends AbstractKirito&#123; public WisdomDecorator(IKirito kirito)&#123; super(kirito); &#125; public void addWisdomBuff()&#123; System.out.println("加智力buff"); &#125; @Override public void releaseSkill() &#123; this.addWisdomBuff(); super.releaseSkill(); &#125;&#125;public class StrengthDecorator extends AbstractKirito&#123; public StrengthDecorator(IKirito kirito)&#123; super(kirito); &#125; public void addStrenthBuff()&#123; System.out.println("加力量buff"); &#125; @Override public void releaseSkill() &#123; this.addStrenthBuff(); super.releaseSkill(); &#125;&#125;public class AgilityDecorator extends AbstractKirito&#123; public AgilityDecorator(IKirito kirito)&#123; super(kirito); &#125; public void addAgilityBuff()&#123; System.out.println("加敏捷buff"); &#125; @Override public void releaseSkill() &#123; this.addAgilityBuff(); super.releaseSkill(); &#125;&#125;public class client&#123; public static void main(String[] args) &#123; IKirito kirito = new Kirito(); kirito = new WisdomDecorator(kirito); kirito = new StrengthDecorator(kirito); kirito = new AgilityDecorator(kirito); kirito.operation(); &#125;&#125; 输出：123456取武器加敏捷buff加力量buff加智力buff放技能捡装备 装饰者模式中的4个角色 被装饰者抽象Component:是一个接口或者抽象类,定义最核心的对象,这个类是装饰者的基类,例如IKirito接口 被装饰者具体实现ConcreteComponent:这是Component接口或抽象类的实现,例如本例中的Kirito 装饰者Decorator:一般是抽象类,实现Component,它里面必然有一个指向Component的引用,例如本例中AbstractKirito 装饰者实现ConcreteDecorator1和ConcreteDecorator2:用来装饰最基本的类,如本例中的AgilityDecorator 2.3 代理模式参考：理解java的三种代理模式 代理模式是一种设计模式，简单说即是在不改变源码的情况下，实现对目标对象的功能扩展。 1. 静态代理12345678910111213141516171819202122232425262728293031public interface IPlayer&#123; void play();&#125;public class Player implements IPlayer&#123; @Override public void play()&#123; System.out.println("进行游戏"); &#125;&#125;public class PlayerProxy implements IPlayer&#123; private IPlayer player; public PlayerProxy(IPlayer player)&#123; this.player = player; &#125; @Override public void play()&#123; System.out.println("寻找伙伴"); player.play(); &#125;&#125;public class Test&#123; public static void main(String[] args) &#123; IPlayer player = new Player(); PlayerProxy proxy = new PlayerProxy(player); proxy.play(); &#125;&#125; 总结：其实这里做的事情无非就是，创建一个代理类SingerProxy，继承了ISinger接口并实现了其中的方法。只不过这种实现特意包含了目标对象的方法，正是这种特征使得看起来像是“扩展”了目标对象的方法。假使代理对象中只是简单地对sing方法做了另一种实现而没有包含目标对象的方法，也就不能算作代理模式了。所以这里的包含是关键。 缺点：这种实现方式很直观也很简单，但其缺点是代理对象必须提前写出，如果接口层发生了变化，代理对象的代码也要进行维护。如果能在运行时动态地写出代理对象，不但减少了一大批代理类的代码，也少了不断维护的烦恼，不过运行时的效率必定受到影响。这种方式就是接下来的动态代理。 2. 动态代理（JDK代理）跟静态代理的前提一样，依然是对Singer对象进行扩展 12345678910public interface IPlayer&#123; void play();&#125;public class Player implements IPlayer&#123; @Override public void play()&#123; System.out.println("进行游戏"); &#125;&#125; 调用Proxy类的静态方法newProxyInstance即可，该方法会返回代理类对象 1234567891011121314151617181920212223public class Test&#123; public static void main(String[] args) &#123; // 1. 创建实例 Player target = new Player(); IPlayer proxy = (IPlayer) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 2. 扩展1 System.out.println("寻找伙伴"); //执行目标对象方法 Object returnValue = method.invoke(target, args); // 3. 扩展2 System.out.println("很开心"); return returnValue; &#125; &#125;); // 4. 目标对象的方法 proxy.play(); &#125;&#125; 总结：以上代码只有1234部分是需要自己写出，其余部分全都是固定代码。由于java封装了newProxyInstance这个方法的实现细节，所以使用起来才能这么方便。缺点：可以看出静态代理和JDK代理有一个共同的缺点，就是目标对象必须实现一个或多个接口，假如没有，则可以使用Cglib代理。 3. Cglib代理前提条件： 需要引入cglib的jar文件，由于Spring的核心包中已经包括了Cglib功能，所以也可以直接引入spring-core-3.2.5.jar 目标类不能为final 目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法 12345public class Player &#123; public void play()&#123; System.out.println("进行游戏"); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Cglib子类代理工厂 */public class ProxyFactory implements MethodInterceptor&#123; // 维护目标对象 private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; // 给目标对象创建一个代理对象 public Object getProxyInstance()&#123; //1.工具类 Enhancer en = new Enhancer(); //2.设置父类 en.setSuperclass(target.getClass()); //3.设置回调函数 en.setCallback(this); //4.创建子类(代理对象) return en.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; // 步骤1 System.out.println("寻找伙伴"); //执行目标对象的方法 Object returnValue = method.invoke(target, args); // 步骤2 System.out.println("很开心"); return returnValue; &#125;&#125;/** * 测试类 */public class Test&#123; public static void main(String[] args)&#123; //目标对象 Player target = new Player(); //代理对象 Player proxy = (Player)new ProxyFactory(target).getProxyInstance(); //执行代理对象的方法 proxy.play(); &#125;&#125; 这里的代码也非常固定，只有步骤1、2是需要自己写出. 总结：三种代理模式各有优缺点和相应的适用范围，主要看目标对象是否实现了接口。 以Spring框架所选择的代理模式举例：在Spring的AOP编程中： 如果加入容器的目标对象有实现接口，用JDK代理 如果目标对象没有实现接口，用Cglib代理 3. 行为型3.1 模板方法模式参考：java设计模式之模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。通俗的说的就是有很多相同的步骤的，在某一些地方可能有一些差别适合于这种模式，如大话设计模式中说到的考试场景中，每个人的试卷都是一样的，只有答案不一样。这种场景就适合于模板方法模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 用抽象基类定义算法框架public abstract class PlayGame&#123; /* * 模板方法 封装了所有子类所遵循的算法框架 */ public final void play()&#123; login(); if(isPlyerWantsBuff())&#123; addBuff(); &#125; releaseSkill(); getAward(); &#125; // 因为login和getAward对所有子类是共同的行为，所以没必要向子类过多开放，所以方法定义为private，这样我们在进行子类编码时可以减少复杂度。 // 这样不需要关注细枝末节，我们只需要关注我们特定业务的实现，这就是模板方法模式的好处。可以封装变与不变，将不变的固化在高层，隐藏其细节。 private void login()&#123; System.out.println("登陆游戏"); &#125; private void getAward()&#123; System.out.println("捡装备"); &#125; /* * Hook 钩子函数,提供一个空的或者默认的实现 子类重写该方法，可以自行决定是否挂钩以及如何挂钩 */ protected boolean isPlyerWantsBuff()&#123; return true; &#125; /* * addBuff()和releaseSkill()这两个方法我们不知道它们在算法框架中的具体实现，因此定义为抽象方法， * 我们用protected进行修饰， 在子类中可见便于进行重写。 */ protected abstract void addBuff(); protected abstract void releaseSkill();&#125;// 具体子类延迟实现步骤/** * 提供制备咖啡的具体实现子类。 具体子类实现延迟步骤，满足特定的业务需求。 * * */public class AsunaPlayGame extends PlayGame&#123; @Override protected void addBuff()&#123; System.out.println("加敏捷Buff"); &#125; @Override protected void releaseSkill()&#123; System.out.println("释放圣母圣咏"); &#125;&#125;public class KiritoPlayGame extends PlayGame&#123; @Override protected boolean isPlyerWantsBuff()&#123; return false; &#125; @Override protected void addBuff()&#123; System.out.println("加敏捷Buff"); &#125; @Override protected void releaseSkill()&#123; System.out.println("释放星爆弃疗斩"); &#125;&#125;// 测试类public class client&#123; public static void main(String[] args) &#123; System.out.println("Kirito 开始游戏"); PlayGame kirito = new KiritoPlayGame(); kirito.play(); System.out.println("\n*********************************"); System.out.println("Asuna 开始游戏"); PlayGame asuna = new AsunaPlayGame(); asuna.play(); &#125;&#125; 控制台输出：1234567891011Kirito 开始游戏登陆游戏释放星爆弃疗斩捡装备*********************************Asuna 开始游戏登陆游戏加敏捷Buff释放圣母圣咏捡装备 模板方法模式适用场景： 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的- 操作的模板方法来替换这些不同的代码。 控制子类扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展。 3.2 观察者模式参考：JAVA设计模式之观察者模式 定义：在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。解释：其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。 抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。 抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。 具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。 具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。 场景有一个NPC务，不定时发布一些任务，在线玩家就可以收到推送消息，不在线就收不到推送消息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/*** * 抽象被观察者接口 * 声明了添加、删除、通知观察者方法 * */public interface Observerable&#123; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObserver();&#125;/*** * 抽象观察者 * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。 * */public interface Observer &#123; public void update(String message);&#125;/** * 被观察者，也就是微信公众号服务 * 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现 */public class NPC implements Observerable&#123; private List&lt;Observer&gt; list; private String message; public NPC()&#123; list = new ArrayList&lt;&gt;(); &#125; @Override public void registerObserver(Observer o)&#123; list.add(o); &#125; @Override public void removeObserver(Observer o)&#123; if(!list.isEmpty())&#123; list.remove(o); &#125; &#125; @Override public void notifyObserver()&#123; for(Observer o : list)&#123; o.update(message); &#125; &#125; public void setMessage(String message)&#123; this.message = message; System.out.println("NPC发布新任务： " + message); notifyObserver(); &#125;&#125;/** * 观察者 * 实现了update方法 */public class Player implements Observer&#123; private String name; private String message; public Player(String name)&#123; this.name = name; &#125; @Override public void update(String message)&#123; this.message = message; receive(message); &#125; public void receive(String message)&#123; System.out.println(this.name + " 收到任务 " + message); &#125;&#125;// 测试类public class client&#123; public static void main(String[] args) &#123; NPC npc = new NPC(); Player kirito = new Player("Kirito"); Player asuna = new Player("Asuna"); Player shino = new Player("Shino"); npc.registerObserver(kirito); npc.registerObserver(asuna); npc.registerObserver(shino); npc.setMessage("第19层boss"); System.out.println("----------------------------------------------"); System.out.println("Shino掉线"); npc.removeObserver(shino); npc.setMessage("第23层boss"); &#125;&#125; 控制台输出：123456789NPC发布新任务： 第19层bossKirito 收到任务 第19层bossAsuna 收到任务 第19层bossShino 收到任务 第19层boss----------------------------------------------Shino掉线NPC发布新任务： 第23层bossKirito 收到任务 第23层bossAsuna 收到任务 第23层boss 总结 这个模式是松偶合的。改变主题或观察者中的一方，另一方不会受到影像。 JDK中也有自带的观察者模式。但是被观察者是一个类而不是接口，限制了它的复用能力。 在JavaBean和Swing中也可以看到观察者模式的影子。]]></content>
      <categories>
        <category>面试</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合总结]]></title>
    <url>%2F2019%2F03%2F27%2FJava%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Java集合总结参考：java三大集合框架 CollectionList ArrayList：Object数组 Vector：Object数组 LinkedList：双向循环链表 Set HashSet（无序，唯一）：基于HashMap实现，底层采用HashMap保存数组。 LinkedHashSet：继承与HashSet，并且其内部是通过LinkedHashMap实现。 TreeSet（有序，唯一）：红黑树。 Map HashMap：JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。 LinkedHashMap：继承自HashMap，所以底层同HashMap，增加了一条双向链表，实现了顺序相关逻辑。 HashTable：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。 TreeSet：红黑树。 ArrayList和LinkedList 线程安全：都不是线程安全的。 底层数据结构：ArrayList使用的是Object数据，LinkedList使用双向循环链表。 插入删除是否受位置影响：ArrayList采用数组存储，所以时间复杂度受位置影响；LinkedList是双向链表，所以近似O(1)。 是否支持快速随机访问：ArrayList支持通过元素的序号访问，LinkedList不可以。 内存空间占用：ArrayList的结尾会预留一定空间，而LinkedList则是每个元素需要空间存放前驱和后继。 ArrayList与Vector Vector的所有方法都是同步的，所以线程安全 ArrayList线程不安全。 HashMap JDK1.8前是数组+链表 JDK1.8后，当容量大于阈值（默认8）后，链表转化为红黑树。 TreeMap、TreeSet和JDK1.8后的HashMap底层都是红黑树。 HashMap和HashTable 线程安全：HashMap不是线程安全的，HashTable内部方法都是synchronized修饰，线程安全。 效率：HashMap更快。 null的支持：HashMap中，只有一个键可以为null，值可以多个为null，HashTable不允许，抛异常。 初始容量和扩充容量：HashMap初始为16，每次扩充原来的2倍，HashTable初始为11，扩充为2n+1 底层结构：JDK1.8后，当容量大于阈值（默认8）后，链表转化为红黑树 Java集合类面试题 为何Collection不从Cloneable和Serializable接口继承Collection接口指定一组对象，对象就是它的元素。如何维护这些元素由具体实现决定。Collection是一个抽象表现，重要的实现。 为何Map接口不继承于Collection接口尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。 如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。 Iterator是什么Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者在迭代过程中移除元素。 Enumeration和Iterator接口的区别Enumeration的速度是Iterator的两倍，也使用更少的内存。Enumeration是非常基础的，也满足了基础的需要。但是，与Enumeration相比，Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。 迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者从集合中移除元素，而Enumeration不能做到。为了使它的功能更加清晰，迭代器方法名已经经过改善。 为何迭代器没有一个方法可以直接获取下一个元素，而不需要移动游标可以在当前Iterator的顶层实现，但是它用得很少，如果将它加到接口中，每个继承都要去实现它，这没有意义。 Iterator和ListIterator之间有什么区别 Iterator可以适用于Set、List，ListIterator只能用于List ListIterator可以双向遍历，Iterator只能向前遍历 ListIterator继承于Iterator，添加了额外的功能，比如添加、替换、获取前面或后面的元素。 遍历List方式1234567891011List&lt;String&gt; strList = new ArrayList&lt;&gt;();// for-each遍历for(String obj : strList)&#123; System.out.println(obj);&#125;// Iterator遍历Iterator&lt;String&gt; it = strList.iterator();while(it.hasNext())&#123; String obj = it.next(); System.out.println(obj);&#125; 迭代器更加线程安全，因为它可以确保，在当前遍历的集合元素被更改的时候，它会抛出ConcurrentModificationException。 如何从给定集合那里创建一个synchronized的集合使用Collections.synchronizedCollection(Collectionc)根据指定集合来获取一个synchronized（线程安全的）集合 哪些集合类是线程安全的Vector、HashTable、Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5并发API包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。]]></content>
      <categories>
        <category>面试</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础知识总结]]></title>
    <url>%2F2019%2F03%2F26%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[计算机网络基础知识总结1. OSI、TCP/IP、五层协议的体系结构 OSI七层结构 物理层：通过媒介传输比特，确定机械及电气规范（Bit） 数据链路层：将比特组装成帧和点到点的传输（帧Frame） 网络层：负责数据包从源到宿的传输和网际互联（数据包Packet） 传输层：提供端对端的可靠报文传输和错误恢复（段Segment） 会话层：建立、管理、终止会话。（会话协议数据单元SPDU） 表示层：对数据翻译，加密，压缩。（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段。（应用协议数据单元APDU） TCP/IP四层结构 数据链路层（网络接口层/从主机到网络层）：模型没有真正描述这一层实现，只是为上一层提供接口。 网络层：处理和分组相关，协议主要包括：IP协议（网际协议）、ICMP协议（Internet网络控制报文协议）、IGMP协议（Internet组管理协议）。 传输层：为两台主机应用提供端对端的通信。TCP、UDP。 应用层：负责处理特殊应用程序细节。Telnet、FTP、SMTP、SNMP（简单网络管理协议） IP层提供不可靠的服务。TCP提供可靠的服务。为了提供可靠服务，TCP采用超时重传、发送和接收端到端的确认分组机制。 2. 常用端口和对应服务 端口 服务 21 FTP 22 SSH 23 TELNET 25 SMTP 53 DNS 80 HTTP 110 POP3 443 HTTPS 1080 SOCKETS 3306 MYSQL 3. TCP三次握手 四次挥手三次握手： 1234sequenceDiagramClient-&gt;&gt;Server: SYN seq = xServer-&gt;&gt;Client: SYN seq = y, ACK = x+1Client-&gt;&gt;Server: ACK = y+1 第一次握手：建立连接，客户端发送连接请求报文段，将SYN位置为1，sequence number为x，然后进入SYN_SEND状态，等待服务端。 第二次握手：服务器接收到请求，对SYN报文段进行确认，设置acknowledge number设置为x+1，将SYN置为1，sequence number为y，将所有信息放入一个报文段中，发送给客户端，进入SYN_RECV状态。 第三次握手：客户端接收到报文段，将acknowledge number置为y+1，向服务端发送ACK报文段，发送完毕后，进入ESTABLISHED状态。 三次握手的原因 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 四次挥手：12345sequenceDiagramClient-&gt;&gt;Server: FIN seq = x+2, ACK = y+1Server-&gt;&gt;Client: ACK = x+3Server-&gt;&gt;Client: FIN seq = y+1Client-&gt;&gt;Server: ACK = y+2 第一次挥手：客户端发送FIN请求关闭。第二次挥手：服务端接收到FIN，回复ACK，序号为收到的+1。第三次挥手：服务端发送一个FIN，关闭服务端到客户端的传输。第四次挥手：客户端收到FIN，回复ACK，序号为收到的+1。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 4. Http和Https的区别HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同： 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443； 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源； 开销：Https通信需要证书，而证书一般需要向认证机构购买； 5. Get与POST的区别 功能：GET 用于获取资源，而 POST 用于传输实体主体。。 REST服务：GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变； 请求参数形式：GET放在HTTP报文请求头中，POST放在请求体中。因为 URL 只支持 ASCII 码；POST 参数支持标准字符集。 安全性：GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 幂等性：GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。（幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。） 请求大小：GET的URL长度有限，POST没有大小限制。 6. IP地址 类别 网络号 地址范围 网络号 主机号 私有地址 A类 以0开头 1.0.0.0 – 127.255.255.255 8位 24位 10.0.0.0 - 10.255.255.255 B类 以10开头 128.0.0.0 – 191.255.255.255 16位 16位 172.16.0.0 - 172.31.255.255 C类 以110开头 192.0.0.0 – 223.255.255.255 24位 8位 192.168.0.0 - 192.168.255.255 7. TCP/UDP区别TCP 优点：可靠，稳定。需要三次握手才能建立接连。传输时有重传、确认、窗口、拥塞控制。 缺点：慢，效率低。各种机制消耗时间、占用资源。 UDP 优点：快，比TCP稍安全。 缺点：不可靠，不稳定。网络不好会丢包。 区别 区别 TCP UDP 连接 面向连接 面向无连接 可靠性 可靠，无丢失，无差错，不重复 不保证可靠性交付 模式 流模式（字节流） 数据报模式（报文） 连接 点到点 支持一对一，一对多，多对一，多对多 首部开销 20字节 8字节 逻辑通信信道 全双工的可靠信道 不可靠信道 速度 慢 快 对系统资源要求 较多 较少 8. ARP协议 首先，每个主机会在自己的ARP缓冲区建立一个ARP列表，保存IP和MAC的对应关系。 当源主机要发送数据时，现在自己的ARP列表是否要对应的IP地址，如果有，直接发送，如果没有，会在网段内所有主机发送数据包，包括：源主机IP，源主机MAC地址，目的主机IP。 当本网段所有主机接收到数据包时，先检查数据包中的目的主机是否是自己的IP，如果不是，忽略；如果是，更新自己ARP，将源主机IP和MAC写入，并将自己的MAC地址写入响应包。 源主机接收到相应包，将目的主机MAC和IP写入ARP列表，然后以此通信。如果一直没有响应包，则ARP查询失败。 9. 从输入网址到获得页面的过程 DNS查询，查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器。 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手； TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求； 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器； 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源； 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。 10. Session 与 Cookie 实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID 大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关 安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全； 服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。 Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。 11. TCP 拥塞控制TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用排序算法-java实现]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-java%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[常用排序算法-java实现快排 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlog₂n) O(nlog₂n) O(n²) O(1)（原地分区递归版） 1234567891011121314151617181920212223public void quickSort(int[] array)&#123; return sort(array, 0, array.length);&#125;private int getMid(int[] array, int start, int end)&#123; int temp = array[start]; while(start &lt; end)&#123; while(start &lt; end &amp;&amp; temp &lt; array[end]) end--; array[end] = array[start]; while(start &lt; end &amp;&amp; temp &gt; array[start]) start++; array[start] = array[high]; &#125; array[start] = temp; return start;&#125;private void sort(int[] array, int start, int end)&#123; if(start &lt; end)&#123; int mid = getMid(array, start, end); sort(array, start, mid - 1); sort(array, mid + 1, end); &#125;&#125; 归并排序 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlog₂n) O(nlog₂n) O(nlog₂n) O(n)） 12345678910111213141516171819202122232425public void mergeSort(int[] array)&#123; return merge(array, 0, array.length - 1);&#125;private void merge(int[] array, int start, int end)&#123; if(end == start) return; int mid = (end + start) / 2; int i = start, j = mid + 1, index = 0; int[] copy = new int[end - start + 1]; merge(array, start, mid); merge(array, mid + 1, end); while(i &lt;= mid &amp;&amp; j &lt;= end)&#123; if(array[i] &gt; array[j]) copy[index++] = array[j++]; else copy[index++] = array[i++]; &#125; while(i &lt;= mid) copy[index++] = array[i++]; while(j &lt;= end) copy[index++] = array[j++]; for(int m = 0; m &gt; copy.length; m++) array[start + m] = copy[m];&#125; 堆排序 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlog₂n) O(nlog₂n) O(nlog₂n) O(1)） 123456789101112131415161718192021public void heapSort(int[] array)&#123; for(int i = array.length - 1; i &gt; 0; i--)&#123; maxHeapify(array, i); int temp = array[i]; array[i] = array[0]; array[0] = temp; &#125;&#125;private void maxHeapify(int[] array, int index)&#123; int child; for(int i = (index - 1)/ 2; i &gt; 0; i--)&#123; child = 2 * i + 1; if(array[child + 1] &gt; array[child]) child++; if(array[child] &gt; array[i])&#123; int temp = array[child]; array[child] = array[i]; array[i] = temp; &#125; &#125;&#125; 基数 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(d*(n+r)) O(d*(n+r)) O(d*(n+r)) O(n+r) 12345678910111213141516171819202122public void radixSort(int[] array, int d)&#123; int[][] bucket = new int[10][array.length]; int n = 1; int index = 0; while(n &lt; d)&#123; int[] order = new int[10]; for(int num : array)&#123; int digit = num / n % 10; bucket[digit][order[digit]] = num; order[digit]++; &#125; for(int i = 0; i &lt; bucket.length; i++)&#123; if(order[i] == 0) continue; for(int j = 0; j &lt; order[i]; j++)&#123; array[index++] = bucket[i][j]; &#125; &#125; index = 0; n *= 1; &#125;&#125; 希尔 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlog2 n) O(nlog2 n) O(nlog2 n) O(1) 12345678910111213141516public void shellSort(int[] array)&#123; int length = array.length; int d = length / 2; while(d &gt; 0)&#123; for(int i = 0; i &lt; length; i++)&#123; for(int j = i; j + d &lt; length; j += d)&#123; if(array[j] &lt; array[i])&#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; &#125; d /= 2; &#125;&#125; 冒泡 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(n²) O(n) O(n²) O(1) 1234567891011public void bubbleSort(int[] array)&#123; for(int i = 0; i &lt; array.length; i++)&#123; for(int j = 0; j &lt; array.length - 1 - i; j++)&#123; if(array[j] &lt; array[j + 1])&#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; &#125;&#125; 选择 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(n²) O(n²) O(n²) O(1) 123456789101112131415public void selectSort(int[] array)&#123; for(int i = 0; i &lt; array.length; i++)&#123; int min = i; for(int j = i + 1; j &lt; array.length; j++)&#123; if(array[j] &lt; array[j + 1])&#123; min = j; &#125; &#125; if(min != i)&#123; int temp = array[i]; array[i] = array[min]; array[min] = temp; &#125; &#125;&#125; 直接插入 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(n²) O(n²) O(n²) O(1) 123456789101112public void insertSort(int[] array)&#123; if(array.length &lt; 1) return; for(int i = 1; i &lt; array.length; i++)&#123; int num = array[i]; int j; for(j = i; j &gt; 0 &amp;&amp; array[j] &gt; num; j--)&#123; array[j] = array[j - 1]; &#125; array[i] = num; &#125;&#125; 总结、对比 算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 稳定性 冒泡排序 O(n²) O(n²) O(n²) O(1) 稳定 选择排序 O(n²) O(n²) O(n²) O(1) 不稳定 直接插入排序 O(n²) O(n) O(n²) O(1) 稳定 折半插入排序 O(n²) O(n) O(n²) O(1) 稳定 希尔排序 O(n^1.3) O(nlogn) O(n²) O(1) 不稳定 归并排序 O(nlog₂n) O(nlog₂n) O(nlog₂n) O(n) 稳定 快速排序 O(nlog₂n) O(nlog₂n) O(n²) O(nlog₂n) 不稳定 堆排序 O(nlog₂n) O(nlog₂n) O(nlog₂n) O(1) 不稳定 基数排序 O(n+k) O(n+k) O(n+k) O(k) 稳定 桶排序 O(n+k) O(n+k) O(n²) O(n+k) (不)稳定 基数排序 O(d(n+k)) O(d(n+k)) O(d(n+kd)) O(n+kd) 稳定 参考文献：https://www.cnblogs.com/morethink/p/8419151.html#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo如何在github上备份]]></title>
    <url>%2F2019%2F03%2F24%2FHexo%E6%8D%A2%E7%94%B5%E8%84%91%E8%A6%81%E5%81%9A%E7%9A%84%2F</url>
    <content type="text"><![CDATA[1. 换机之前的步骤 克隆项目到本地 1git clone 项目 进入项目文件夹，删掉除.git外的所有。 把原来hexo内所有内容复制过来。 创建分支 1git checkout -b hexo 添加add、commit、推送，操作类似普通项目 123git add --allgit commit -m &quot;&quot;git push --set-upstream origin hexo 发布博客和更新 12hexo new post &quot;新文章&quot;hexo d -g git三部曲 123git add . git commit -m &quot;注释&quot; git push origin hexo 2. 换机之后的步骤 clone到本地 1git clone -b hexo 项目 发布博客和更新 12hexo new post &quot;新文章&quot;hexo d -g git三部曲 123git add . git commit -m &quot;注释&quot; git push origin hexo 参考文献： https://blog.csdn.net/heimu24/article/details/81210640 3. 可能出现的问题1. themes/next无法提交根本原因是next主题也是一个repo。 剪切 themes/next/.git文件夹到其它处 从暂存区删除该文件夹 1git rm --cache themes/next 使用git status查看状态 git三部曲 再移回themes/next/.git文件夹 2. themes/next在git add后在github仍是空新机pull下来后hexo没有页面，原因是旧的themes/next中有.git文件夹，删掉.git后再重新传一下，步骤：git rm --cached themes/next +重新git add themes/next 三部曲。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库其他知识]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数据库其他知识 其他知识delete truncate drop区别 区别 delete truncate drop 类型回滚 可回滚 不可回滚 不可回滚 删除内容 表结构还在，删除表全部或部分内容 表结构还在，删除全部内容 删除表，所有数据、索引、权限一并删除 删除速度 逐行删除，速度慢 速度快 速度快 存储过程预编译的sql语句，一次创建，多次使用。 优点 预编译，效率高。 存放在数据库，减少网络传输。 安全性高，需要一定权限。 一次创建可多次使用，提高开发效率。 视图从一个表或多个表导出的表，是虚表，不存具体数据。 主从复制将主数据库的DDL、DML操作记录到二进制文件（BINLOG），传输到从数据库，从数据库重新执行，使得从数据库数据和主数据库保持一致。 主从复制作用 主数据库故障可以切换到从数据库； 可以读写分离； 从数据库可以日志备份。 复制过程 主数据库更新数据完成前，将操作记录顺序记录到BINLOG； 从数据库开启一个I/O线程，该线程在主数据库打开一个普通连接，将读到的事件写入到中继日志，如果读取的进度跟上了master，就进入睡眠等待； 从数据库的SQL线程将读取中继日志，并顺序执行操作。 大表数据查询的优化 优化Schema，sql语句、索引。 加缓存，memcached，redis 主从复制，读写分离 垂直拆分，分布式系统 水平切分，要选择合适的sharding key，为了好的查询效率，表结构也要改变，应用也需要改变，sql中尽量带sharding key，将数据定位到限定的表去查，而不是全部的表。 参考文献：https://www.weiweiblog.cn/databases/]]></content>
      <categories>
        <category>面试</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务总结]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[数据库事务总结 事务事务是一个不可分割的数据库操作序列，是数据库并发操作的基本单位，其结果是从一种一致性状态到另一种一致性状态。 四大特性（ACID）原子性（Atomicity）事务是数据库逻辑工作单位，其操作要么全做，要么全不做。 一致性（Consistency）其结果必须是从一种一致性状态到另一种一致性状态。 隔离性（Isolation）一个事务的执行不能被其他事务干扰。 持久性（Duration）持久性表示一旦事务被提交了，数据库的数据改变就是永久性的，即使遇到故障也不会丢失提交的操作。 不考虑隔离性会出现的问题 脏读： 一个事务读到了另一个未提交事务的数据。 不可重复读：一个事务两次查询的间隔中，另一个事务修改并提交了数据，导致两次查询结果不同。 幻读：一个事务两次查询中数据笔数不一致。 不可重复读和幻读都是查询中被另一个事务修改并提交了，不同的是不可重复读查询的是同一条数据，幻读是一批数据（比如数据的条数）。 隔离级别 Read Uncommitted(读未提交)：所有事务都可以看到其他事务未提交的结果。一般很少用。 Read commited(读已提交)：一个事务只能看见已提交的结果。除mysql外大多数数据库默认。 Repeatable Read(可重复读)：确保了同一个事务的多个实例并发读数据时能看到相同的结果。mysql默认。 Serializable(顺序读)：最高的隔离级别，解决了幻读，但会出现大量超时和锁竞争。 事务隔离级别对比 事务隔离级别 脏读 不可重复读 幻读 Read Uncommitted 允许 允许 允许 Read commited 不允许 允许 允许 Repeatable Read 不允许 不允许 允许 Serializable 不允许 不允许 不允许 隔离级别与锁Read Uncommitted：读操作不加S锁。Read commited：读操作加S锁，在语句执行完释放锁。Repeatable Read：读操作加S锁，事务提交后释放锁。Serializable：在Repeatable read的基础上，加范围锁。 操作start transaction;开始事务 commit; 提交 rollback; 回滚 参考文献：https://www.weiweiblog.cn/databases/]]></content>
      <categories>
        <category>面试</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer算法题 27——36]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98%2027-36%2F</url>
    <content type="text"><![CDATA[剑指offer算法题 27——36剑指offer算法题 2727 二叉搜索树转换成双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 “不能创建任何新的结点”，但是需要new tail new tail 递归或栈的方法中序遍历。 1234567891011121314151617181920212223242526272829303132333435363738/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; TreeNode head = null; TreeNode tail = null; public TreeNode Convert(TreeNode pRootOfTree) &#123; if(pRootOfTree == null) return null; ConvertNode(pRootOfTree); return head; &#125; private void ConvertNode(TreeNode node)&#123; if(node == null) return; ConvertNode(node.left); if(head == null)&#123; head = node; tail = node; &#125;else&#123; tail.right = node; node.left = tail; tail = node; &#125; ConvertNode(node.right); &#125;&#125; 28 字符串排列输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 按字典序打印，需要把结果：Collections.sort(res); 避免重复的，需要判断：if(i != index &amp;&amp; chars[i] == chars[index]) 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;public class Solution &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); public ArrayList&lt;String&gt; Permutation(String str) &#123; char[] chars = str.toCharArray(); if(str.length() == 0) return res; res = Permutation(chars, 0); Collections.sort(res); return res; &#125; private ArrayList&lt;String&gt; Permutation(char[] chars, int index)&#123; if(index == chars.length - 1) res.add(String.valueOf(chars)); else&#123; for(int i = index; i &lt; chars.length; i++)&#123; if(i != index &amp;&amp; chars[i] == chars[index])&#123; continue; &#125; swap(chars, i, index); Permutation(chars, index + 1); swap(chars, index, i); &#125; &#125; return res; &#125; private void swap(char[] chars, int i ,int j)&#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; &#125;&#125; 29 数组中次数超过的数数组中有一个数字出现的次数超过的数数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 可以用hashmap 可以先排序 超过一半，即超过其他数之和。用一个num记录当前count大于零的数，count表示此数的次数，如果新遍历的数不是num，count–，否则count++，当count归零，更新num。 1234567891011121314151617181920public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if(array.length == 0) return 0; int num = array[0], count = 1; for(int i = 1; i &lt; array.length; i++)&#123; if(array[i] != num)&#123; if(count == 0) num = array[i]; else count--; &#125;else count++; &#125; if(count &gt; 0) return num; else return 0; &#125;&#125; 30 最小的K个数输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 1234567891011121314151617181920212223242526272829import java.util.PriorityQueue;import java.util.ArrayList;import java.util.Comparator;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(k &gt; input.length || k == 0) return res; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(k, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2.compareTo(o1); &#125; &#125;); for(int i = 0; i &lt; input.length; i++)&#123; if(queue.size() &lt; k)&#123; queue.offer(input[i]); &#125;else if(queue.peek() &gt; input[i])&#123; queue.poll(); queue.offer(input[i]); &#125; &#125; while(!queue.isEmpty())&#123; res.add(queue.poll()); &#125; return res; &#125;&#125; 31 连续子数组的最大和HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 123456789101112131415public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; int cur = 0; int max = Integer.MIN_VALUE; for(int i = 0; i &lt; array.length; i++)&#123; if(cur &gt; 0) cur += array[i]; else cur = array[i]; if(cur &gt; max) max = cur; &#125; return max; &#125;&#125; 32 整数中1出现的次求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 规律：当计算右数第 i 位包含的 x 的个数时 1. 取第 i位左边(高位)的数字，乘以 10^(i-1)，得到基础值 a 2. 取第 i 位数字，计算修正值 3. 如果大于 x , 则结果为 a + 10^(i-1) 4. 如果小于 x，则结果为 a 5. 如果等于 x，则取第 i 位右边(低位)数字，设为 b，最后结果为 a + b + 1 1234567891011121314151617181920// n - n / i * i 是当前左边一位public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; for(int i = 1; n / i != 0; i *= 10)&#123; int base = n / i / 10 ; base *= i; int bias = n / i % 10; if(bias &lt; 1) count += base; else if(bias &gt; 1) count += base + i; else&#123; count += base + n - n / i * i + 1; &#125; &#125; return count; &#125;&#125; 33 把数组排成最小的数输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 类似冒泡排序 12345678910111213141516171819202122public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int n : numbers)&#123; list.add(String.valueOf(n)); &#125; for(int i = 0;i &lt;list.size(); i++)&#123; for(int j = 0; j &lt; list.size() - 1 - i; j++)&#123; if(Long.parseLong(list.get(j) + list.get(j + 1)) &gt; Long.parseLong(list.get(j + 1) + list.get(j))) &#123; String temp = list.get(j + 1); list.set(j + 1 , list.get(j)); list.set(j, temp); &#125; &#125; &#125; String res = &quot;&quot;; for (String s:list) &#123; res += s; &#125; return res; &#125;&#125; 34 丑数把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 12345678910111213141516171819import java.util.PriorityQueue;public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index == 0) return 0; PriorityQueue&lt;Long&gt; queue = new PriorityQueue(); queue.offer(1L); long num = 1L; for(int i = 0; i != index; i++)&#123; num = queue.poll(); while(!queue.isEmpty() &amp;&amp; num == queue.peek()) queue.poll(); queue.offer(num * 2); queue.offer(num * 3); queue.offer(num * 5); &#125; return (int)num; &#125;&#125; 35第一个只出现一次的字符在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 123456789101112131415161718import java.util.HashMap;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; char[] cs = str.toCharArray(); HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : cs) &#123; if (!map.containsKey(c)) map.put(c, 1); else map.put(c, map.get(c) + 1); &#125; for (int i = 0; i &lt; cs.length; i++) &#123; if (map.get(cs[i]) == 1) return i; &#125; return -1; &#125;&#125; 36 数组中的逆序对在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 归并排序，注意是从后往前放copy数组。 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public int InversePairs(int [] array) &#123; if(array.length == 0) return 0; return mergeSort(array, 0, array.length - 1); &#125; private int mergeSort(int[] array, int start, int end)&#123; int mid = (end + start)/ 2; if(end == start) return 0; int leftCount = mergeSort(array, start, mid); int rightCount = mergeSort(array, mid + 1, end); int i = mid, j = end; int count = 0; int index = end - start; int[] copy = new int[end - start + 1]; while(i &gt;= start &amp;&amp; j &gt;= mid + 1)&#123; if(array[i] &gt; array[j])&#123; count = (count + j - mid) % 1000000007; copy[index--] = array[i--]; &#125;else&#123; copy[index--] = array[j--]; &#125; &#125; while(i &gt;= start)&#123; copy[index--] = array[i--]; &#125; while(j &gt;= mid + 1)&#123; copy[index--] = array[j--]; &#125; for(int k = 0; k &lt; copy.length; k++) array[start + k] = copy[k]; return (leftCount + rightCount + count) % 1000000007; &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库索引总结]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[数据库索引总结 数据库索引索引通常是由B树或者B+树实现。 B树和B+树的区别 B树的键和值也存在内部节点和叶子结点中，B+树内部结点只存键，叶子结点存键和值。 B+树的叶子结点有一条链相连。 B树的好处B树在内部存键值，频繁访问的节点在根节点附近可以提高查询效率，如果特定数据是重复读取，B树更好。 B+树的好处一次读取大量数据时，因为B+树内部节点只存键，因此可以读取更多键，又因为叶子节点有链，读取大量数据时不需要每次都遍历内部节点。 数据库使用B+还不是BB树只适合随机检索，B+树同时适合随机检索和顺序检索。 B+树空间利用率更高，I/O次数少，磁盘读写少。索引也很大，需要以文件的形式存在磁盘中。索引查找就会产生I/O操作。B+树可以一次读取更多的关键字，因此I/O次数少。 B+树查询效率更稳定。B树关键字在内部节点中也有，找到关键字就能确定记录。性能代价相当于二分查找。B+树每次都是跟到叶节点，效率更稳定。 B+树顺序遍历效率也不低。B+树叶子结点有链。 索引类型 主键索引：数据列不允许重复，不允许为null，一个表只能有一个主键索引。 唯一索引：数据列不允许重复，允许为null，一个表允许多个列创建唯一索引。 普通索引：没有唯一性限制，可以为空。 全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。 联合索引：可以多个列共同创建联合索引。一个查询可以使用其中一个列，但必须遵守最左前缀原则。 聚集索与非聚集索 聚集索引：各行的物理顺序和逻辑顺序相同，一个表只能有一个。 非聚集索引：数据与索引在不同位置，索引中存在指向数据的指针，可以有多个。非聚集索引，分成普通索引，唯一索引，全文索引。 InnoDB的数据文件本身就是索引文件。InnoDB数据文件按聚集索引，所以InnoDB必须有主键。InnoDB聚集索引规则： 如果有主键，主键就是聚集索引。 如果没有主键，第一个唯一非空索引就是聚集索引。 如果1、2都没有，会生成一个隐藏的主键作为聚集索引，它是6个字节的列，随着数据插入自增。 MyISAM和InnoDB索引实现 索引 MyISAM InnoDB 主键索引 在主键索引中，索引页中存放的是主键和指向数据页的偏移量；数据页中存放的是主键和该主键所属行记录的地址空间。 在主键索引中，索引页中存放的是主键和指向数据页的偏移量；数据页中存放的是主键和该主键所属行记录的地址空间。 辅助索引 索引页仍然存放主键和和指向数据页的偏移量，但数据页存放的是完整的记录。 索引节点存放的内容一样，仍然是键值信息和指向数据页的偏移量；但数据页中存放的是键值信息和该键值对应的主键。然后通过主键查询主键索引就能找到该条记录。 索引的优点 创建唯一性索引，可以确保每行数据的唯一性。 提高数据检索效率。 加快表与表之间的连接。 使用分组和排序字句检索时，可以加快检索时间。 通过使用索引，在查询过程中，使用查询优化器，提高系统性能。 索引的缺点 时间方面：创建和维护需要时间。对数据增删改也需要对索引维护。 空间方面：索引需要占据物理空间。 索引的优化 非空字段：索引的列最好为非空。空值很难优化，用其他方式（0，特殊值等）代替空值。 取离散大的列：将更离散的数据放在联合索引前面。 索引字段越小越好：数据以页为单位存储，一页数据越多，一次IO操作得到的数据越多。 对 where,on,group by,order by 中出现的列使用索引。 对于like查询，%不放在前面。 最左前缀匹配原则。 最左前缀匹配原则mysql会向右匹配到范围查询（&lt;,&gt;,between等），=、in放在左边。 = in 可以乱序。]]></content>
      <categories>
        <category>面试</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库范式总结]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据库范式范式1. 第一范式每个属性都不可再分。 2. 第二范式消除了非主属性对于码的部分函数依赖。所有非主属性都必须和主键有完全依赖关系，不能存在有某个非主属性只和主键的一部分有关。 12345部分函数依赖：若XY是关系R中的属性，X-&gt;Y，X&apos;是X的子集，若存在X&apos;-&gt;Y，则Y部分函数依赖X。安全函数依赖：若XY是关系R中的属性，X-&gt;Y，X&apos;是X的子集，若每个X&apos;！-&gt;Y，则Y完全函数依赖X。传递函数依赖：在关系R(U)中，XYZ是R的三个属性集合，若X确定Y，Y确定Z，X不包含Y，Y不确定Z，(XUY)∩Z为空，则称Z传递函数依赖于X。 3. 第三范式消除了非主属性对于码的传递函数依赖。不仅要满足第二范式，而且所有属性都要互相独立，没有传递关系。]]></content>
      <categories>
        <category>面试</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer算法题 3——26]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98%203-26%2F</url>
    <content type="text"><![CDATA[剑指offer算法题 3——2603 二维数组中的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 123456789101112131415161718192021//从右上角开始遍历。public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int row = array.length; int col = array[0].length; if(row==0 || col==0) return false; int i = 0, j = col - 1; while(array[i][j]!=target)&#123; if(array[i][j]&lt;target)&#123; i++; &#125;else&#123; j--; &#125; if(i &gt; row - 1 || j &lt; 0)&#123; return false; &#125; &#125; return true; &#125;&#125; 04 替换空格请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 123456789101112public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; String res = ""; for(int i=str.length()-1;i&gt;=0;i--)&#123; if(str.charAt(i)==' ') res = "%20" + res; else res = str.charAt(i) + res; &#125; return res; &#125;&#125; 05 从尾到头打印链表输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 123456789101112131415161718192021222324252627282930313233// 用栈 或 反转链表/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); ListNode newHead = null; ListNode left = null; ListNode now = listNode; while(now != null)&#123; left = newHead; newHead = now; now = now.next; newHead.next = left; &#125; while(newHead != null)&#123; res.add(newHead.val); newHead = newHead.next; &#125; return res; &#125;&#125; 06 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 12345678910111213141516171819202122232425262728/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */import java.util.Arrays;public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre.length == 0)&#123; return null; &#125; TreeNode root = new TreeNode(pre[0]); int mid = 0; for(int i = 0;i &lt; in.length;i++)&#123; if(in[i] == pre[0]) mid = i; &#125; root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, 1 + mid), Arrays.copyOfRange(in, 0, mid)); root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, 1 + mid, pre.length), Arrays.copyOfRange(in, mid + 1, in.length)); return root; &#125;&#125; 07 两个栈实现队列123456789101112131415161718192021import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if(stack2.isEmpty())&#123; while(!stack1.isEmpty())&#123; int num = stack1.pop(); stack2.push(num); &#125; &#125; return stack2.pop(); &#125;&#125; 08 旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 123456789101112131415161718192021import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; if(array.length == 0) return 0; int low = 0; int mid = (array.length + low) / 2; int high = array.length - 1; while(low &lt; high)&#123; mid = low + (high - low) / 2; if(array[mid] &gt; array[high])&#123; low = mid + 1; &#125;else if (array[mid] &lt; array[high])&#123; high = mid; &#125;else&#123; high--; &#125; &#125; return array[low]; &#125;&#125; 09 斐波那契数列大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 1234567891011121314151617181920212223// 使用动态规划public class Solution &#123; public int Fibonacci(int n) &#123; int f1 = 0; int f2 = 1; int index = 0; int res = 0; while(index &lt;= n)&#123; if(index == 0)&#123; res = f1; &#125;else if(index == 1)&#123; res = f2; &#125; else&#123; res = f1 + f2; f1 = f2; f2 = res; &#125; index ++; &#125; return res; &#125;&#125; 10 二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 123456789101112131415161718192021222324// 自己写的public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; for(int i = 0; i &lt; 32; i++)&#123; if((n &amp; 1) == 1)&#123; count++; &#125; n = n &gt;&gt; 1; &#125; return count; &#125;&#125;// 网上更简练的，n按位与n-1，可以将最后一个1变成0public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; while(n!=0)&#123; count += 1; n &amp;= (n-1); &#125; return count; &#125;&#125; 11 数值的整数次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 12345678910111213141516// &amp; 1 判断奇偶public class Solution &#123; public double Power(double base, int exponent) &#123; if(base == 0) return 0; if(exponent == 0) return 1; if(exponent &lt; 0) return 1 / Power(base, exponent * (-1)); if((exponent &amp; 1) == 1)&#123; return base * Power(base, exponent / 2) * Power(base, exponent / 2); &#125;else&#123; return Power(base, exponent / 2) * Power(base, exponent / 2); &#125; &#125;&#125; 14 调整数组顺序使奇数位于偶数前面输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 12345678910111213141516171819202122// 不开空间，用指针也比较麻烦，时间复杂度也不低，没找到指针比较好的办法import java.util.List;import java.util.ArrayList;public class Solution &#123; public void reOrderArray(int [] array) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; array.length; i++)&#123; if((array[i] &amp; 1) == 1)&#123; list1.add(array[i]); &#125;else&#123; list2.add(array[i]); &#125; &#125; List&lt;Integer&gt; listAll = new ArrayList&lt;Integer&gt;(); listAll.addAll(list1); listAll.addAll(list2); for(int i = 0; i &lt; array.length; i++)&#123; array[i] = listAll.get(i); &#125; &#125;&#125; 15 输入一个链表，输出该链表中倒数第k个结点链表中倒数第k个结点 12if(right == null) return null; 注意这句的位置，要放在right = right.next;前面，否则{1,2,3,4,5},5/6 会有问题。12345678910111213141516171819202122232425262728/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; if(k == 0 || head == null) return null; int index = 0; ListNode right = head; for(int i = 0;i &lt; k; i++)&#123; if(right == null) return null; right = right.next; &#125; ListNode left = head; while(right != null)&#123; right = right.next; left = left.next; &#125; return left; &#125;&#125;## 16 反转链表输入一个链表，反转链表后，输出新链表的表头。要注意 now = now.next; newHead.next = left;的先后顺序 123456789101112131415161718192021222324252627// 要注意 now = now.next; newHead.next = left;的先后顺序/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode newHead = null; ListNode left = null; ListNode now = head; while(now != null)&#123; left = newHead; newHead = now; now = now.next; newHead.next = left; &#125; return newHead; &#125;&#125; 17 合并两个排序的链表输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/// 非递归public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null) return list1; ListNode head = new ListNode(-1); ListNode now = head; while(list1 != null &amp;&amp; list2 != null)&#123; if(list1.val &lt; list2.val)&#123; now.next = list1; list1 = list1.next; &#125; else&#123; now.next = list2; list2 = list2.next; &#125; now = now.next; &#125; if(list1 != null) now.next = list1; if(list2 != null) now.next = list2; return head.next; &#125;&#125;// 递归public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null) return list1; ListNode node = list1; if(list1.val &lt; list2.val)&#123; node = list1; node.next = Merge(list1.next, list2); &#125;else&#123; node = list2; node.next = Merge(list1, list2.next); &#125; return node; &#125;&#125; 18 树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 12345678910111213141516171819202122232425262728293031323334/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root2 == null || root1 == null) return false; return isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2); &#125; private boolean isSubtree(TreeNode root1, TreeNode root2) &#123; if(root2 == null)&#123; return true; &#125; if(root1 == null) return false; if(root1.val == root2.val)&#123; return isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right); &#125;else&#123; return false; &#125; &#125;&#125; 19 二叉树的镜像操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112131415161718192021222324/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root == null) return; TreeNode node = root.left; root.left = root.right; root.right = node; Mirror(root.left); Mirror(root.right); &#125;&#125; 20 顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 12345678910111213141516171819202122232425262728import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; if(matrix.length == 0 || matrix[0].length == 0) return null; int row = matrix.length, col = matrix[0].length; int top = 0, left = 0, right = col - 1, buttom = row - 1; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); while(left &lt;= right &amp;&amp; top &lt;= buttom)&#123; for(int i = left; i &lt;= right; i++)&#123; res.add(matrix[top][i]); &#125; for(int i = top + 1; i &lt;= buttom; i++)&#123; res.add(matrix[i][right]); &#125; if(top != buttom) for(int i = right - 1; i &gt;= left; i--)&#123; res.add(matrix[buttom][i]); &#125; if(left != right) for(int i = buttom - 1; i &gt; top; i--)&#123; res.add(matrix[i][left]); &#125; left++;top++;right--;buttom--; &#125; return res; &#125;&#125; 21 包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 12345678910111213141516171819202122232425262728293031323334import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;(); public void push(int node) &#123; stack.push(node); int min = node; if(!minStack.isEmpty()) min = minStack.pop(); minStack.push(min); if(node &lt; min) min = node; minStack.push(min); &#125; public void pop() &#123; stack.pop(); minStack.pop(); &#125; public int top() &#123; int num = stack.pop(); stack.push(num); return num; &#125; public int min() &#123; int num = minStack.pop(); minStack.push(num); return num; &#125;&#125; 22 栈的压入、弹出序列输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 1234567891011121314151617181920212223import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA.length != popA.length || pushA.length == 0 || popA.length == 0) return false; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int index = 0; for(int i = 0; i &lt; pushA.length; i++)&#123; stack.push(pushA[i]); while(stack.peek() == popA[index])&#123; stack.pop(); index++; if(index == popA.length) return true; &#125; &#125; return false; &#125;&#125; 23 从上往下打出二叉树从上往下打印出二叉树的每个节点，同层节点从左至右打印。 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;import java.util.Queue;import java.util.LinkedList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i = 0; i &lt; size; i++)&#123; TreeNode node = queue.poll(); res.add(node.val); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); &#125; &#125; return res; &#125;&#125; 24 二叉搜索树的后序遍历输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 1234567891011121314151617181920public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence.length == 0) return false; return judge(sequence, 0, sequence.length -1 ); &#125; private boolean judge(int[] sequence, int start ,int end)&#123; int root = end; int i = start; if(start &gt;= end) return true; while(i &lt; end &amp;&amp; sequence[i] &lt; sequence[end]) i++; for(int j = i; j &lt; end; j++)&#123; if(sequence[j] &lt; sequence[end]) return false; &#125; return judge(sequence, start, i - 1 ) &amp;&amp; judge(sequence, i, end - 1); &#125;&#125; 25 二叉树中和为某一值的路径输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); if(target &gt; 0 &amp;&amp; root != null) find(root, target, array); return res; &#125; private void find(TreeNode root,int target, ArrayList&lt;Integer&gt; array)&#123; array.add(root.val); target = target - root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) res.add((ArrayList&lt;Integer&gt;)array.clone()); else &#123; if(root.left != null) find(root.left, target, array); if(root.right != null) find(root.right, target, array); &#125; array.remove(array.size() - 1); &#125;&#125; 26 复杂链表的复制输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） “输出结果中请不要返回参数中的节点引用”，在第三步时，就要RandomListNode newNode。 12345678910111213141516171819202122232425262728293031323334353637383940/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead == null) return null; RandomListNode node = pHead; while(node != null)&#123; RandomListNode newNode = new RandomListNode(node.label); newNode.next = node.next; node.next = newNode; node = node.next.next; &#125; node = pHead; while(node != null)&#123; if(node.random != null) node.next.random = node.random.next; node = node.next.next; &#125; node = pHead; RandomListNode newHead = node.next; while(node != null)&#123; RandomListNode newNode = node.next; node.next = node.next.next; newNode.next = newNode.next == null? null: newNode.next.next; node = node.next; &#125; return newHead; &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建ShadowSocks]]></title>
    <url>%2F2018%2F09%2F21%2F%E6%90%AD%E5%BB%BAShadowSocks%2F</url>
    <content type="text"><![CDATA[1. 搭建ShadowSocks1.1 客户端下载https://shadowsocks.org/en/download/clients.html 1.2 ss的配制与使用1. 检查Python版本1$ python -version 2. 安装m2crypto和python-setuptools1$ yum install m2crypto python-setuptools 3. 安装pip123yum -y install epel-releaseyum -y install python-pip 或者（没试过）1$ easy_install pip 4. 安装ss1$ pip install shadowsocks 5. 配置服务器参数1$ vi /etc/shadowsocks.json 12345678910&#123; &quot;server&quot;:&quot;my_server_ip&quot;, //服务器的IP地址 &quot;server_port&quot;:7711, //服务器的端口 &quot;local_address&quot;: &quot;127.0.0.1&quot;, //本机IP地址 &quot;local_port&quot;:1080, //本机端口 &quot;password&quot;:&quot;mypassword&quot;, //自己设定的密码 &quot;timeout&quot;:300, //超出时间 &quot;method&quot;:&quot;aes-256-cfb&quot;, //加密方法，推荐使用&quot;aes-256-cfb&quot; &quot;fast_open&quot;: false //true 或 false&#125;&#125; 若是多用户模式，将server_port和password合并为port_password： 1234&quot;port_password&quot;: &#123; &quot;443&quot;: &quot; mypassword 1”, //对应端口设定不同的密码 &quot;8888&quot;: &quot; mypassword 2” &#125;, 6. 安装geventGevent可以提高ss性能，由于gevent依赖于libevent和greenlet 123$ yum install -y libevent$ pip install greenlet$ pip install gevent 7. 配置防火墙为了提高系统的安全性，需要安装防火墙 1$ yum install firewalld 启动防火墙 1$ systemctl start firewalld 开启相应端口 12$ firewall-cmd --permanent --zone=public --add-port=443/tcp$ firewall-cmd --reload 1.3 查看修改ss服务器的端口密码 查看当前ss服务器所开放的端口 1ss -lntp | grep ssserver 查看当前ss服务器的密码，通过以下命令可见ss的配置文件，配置文件中自然有密码 1ps aux | grep ssserver 用cat查看下配置文件即可看见密码了，vim修改 1vim /etc/shadowsocks.json ss启动停止方法 启动，停止，重启，状态： 12345ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stopssserver -c /etc/shadowsocks.json -d restart 参考：https://github.com/easonhuang123/blog/issues/1https://blog.whsir.com/post-1045.html 2. 搭建SSR2.1 服务器1.install install git git clone https://github.com/shadowsocksr/shadowsocksr.git （github ssr） 2.Usage for single user on linux platformIf you clone it into “/shadowsocksr”move to “/shadowsocksr”, then run: 1bash initcfg.sh move to “~/shadowsocksr/shadowsocks”, then run: 1python server.py -p 443 -k password -m aes-128-cfb -O auth_aes128_md5 -o tls1.2_ticket_auth_compatible Check all the options via -h. You can also use a configuration file instead (recommend), move to “/shadowsocksr” and edit the file “user-config.json”, then move to “/shadowsocksr/shadowsocks” again, just run: 1python server.py To run in the background: 1./logrun.sh To stop: 1./stop.sh To monitor the log: 1./tail.sh 3.配置firewall，开放端口 （for centos 7）12[root@centos7 ~]# firewall-cmd --zone=public --add-port=80/tcp --permanent[root@centos7 ~]# firewall-cmd --reload # 重启防火墙 2.2 客户端github ssr 3. 关于firewallhttps://www.cnblogs.com/Sungeek/p/8257681.html 当下面实验修改的是永久生效的策略记录时，必须执行”–reload“参数后才能立即生效，否则要重启后再生效。 查看当前的区域： 12[root@CentOS7 ~]# firewall-cmd --get-default-zonepublic 查询网卡的区域： 12[root@Centos7 ~]# firewall-cmd --get-zone-of-interface=eno16777736public 在public中分别查询ssh与http服务是否被允许： 1234[root@Centos7 ~]# firewall-cmd --zone=public --query-service=sshyes[root@Centos7 ~]# firewall-cmd --zone=public --query-service=httpno 实例A:允许https服务流量通过public区域，要求立即生效且永久有效： 方法一:分别设置当前生效与永久有效的规则记录： 1234[root@Centos7 ~]# firewall-cmd --zone=public --add-service=httpssuccess[root@Centos7 ~]# firewall-cmd --permanent --zone=public --add-service=httpssuccess 方法二:设置永久生效的规则记录后读取记录： 1234[root@Centos7 ~]# firewall-cmd --permanent --zone=public --add-service=httpssuccess[root@Centos7 ~]# firewall-cmd --reloadsuccess 实例B:不再允许http服务流量通过public区域，要求立即生效且永久生效： 12345[root@Centos7 ~]# firewall-cmd --permanent --zone=public --remove-service=httpsuccess[root@Centos7 ~]# firewall-cmd --reload success 实例C:允许8080与8081端口流量通过public区域，立即生效且永久生效： 1234[root@Centos7 ~]# firewall-cmd --permanent --zone=public --add-port=8080-8081/tcpsuccess[root@Centos7 ~]# firewall-cmd --reload success 实例D:查看模拟实验中的规则： 1234[root@Centos7 ~]# firewall-cmd --zone=public --list-services dhcpv6-client http https ssh[root@Centos7 ~]# firewall-cmd --zone=public --list-ports 8080-8081/tcp 实例E：将访问主机888端口的请求转发至22端口： 1234[root@Centos7 ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.0.100success[root@Centos7 ~]# firewall-cmd --reload success 例如安装Nagios后，要开放5666端口与服务器连接，命令如下 ;) 1234567[root@centos7 ~]# firewall-cmd --add-port=5666/tcp 即时打开，这里也可以是一个端口范围，如1000-2000/tcpsuccess[root@centos7 ~]# firewall-cmd --permanent --add-port=5666/tcp 写入配置文件success[root@centos7 ~]# firewall-cmd --reload 重启防火墙success[root@centos7 ~]# ;) CentOS 7快速开放端口： CentOS升级到7之后，发现无法使用iptables控制Linuxs的端口，baidu之后发现Centos 7使用firewalld代替了原来的iptables。下面记录如何使用firewalld开放Linux端口： 开启端口 1[root@centos7 ~]# firewall-cmd --zone=public --add-port=80/tcp --permanent 查询端口号80 是否开启： 1[root@centos7 ~]# firewall-cmd --query-port=80/tcp 查询有哪些端口是开启的: 1[root@centos7 ~]# firewall-cmd --list-port 命令含义： –zone #作用域–add-port=80/tcp #添加端口，格式为：端口/通讯协议–permanent #永久生效，没有此参数重启后失效 重启防火墙 1[root@centos7 ~]# firewall-cmd --reload]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>ShadowSocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件夹中添加-右键打开命令行窗口（转载）]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[将“在此处打开命令窗口”添加到右键菜单（转载）注册表编辑器中 \HKEY_CLASSES_ROOT\Directory\shell\ \HKEY_CLASSES_ROOT\Directory\Background\shell\ \HKEY_CLASSES_ROOT\Drive\shell\ \HKEY_CLASSES_ROOT\LibraryFolder\background\（要新建shell项） 上述项中每个都执行的步骤： 放在\shell\上，右键，选择新建-项：OpenCmdHere 进入OpenCmdHere，修改值为OpenCmdHere 选择新建-字符串值：Icon \OpenCmdHere，新建-项：command 进入command，修改值为： 1Powershell -windowstyle hidden -Command &quot;Start-Process cmd.exe -ArgumentList &apos;/s,/k, pushd,%V&apos; -Verb RunAs&quot; 原贴地址：https://www.ithome.com/html/win10/309633.htm]]></content>
      <categories>
        <category>Windows tips</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信跳一跳Python脚本]]></title>
    <url>%2F2018%2F01%2F09%2F%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3python%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[微信跳一跳Python脚本adb+python，用的话先装adb， 感觉80%能跳到中心吧。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123# -*- coding: utf-8 -*-import timefrom PIL import Imageimport osimport mathdef isPixFuzzyDiff(r,g,b,pix): if abs(r - pix[0]) &lt; 10 and abs(g - pix[1]) &lt; 10 and abs(b - pix[2]) &lt; 10: return False else: return Truedef isPixAccurateDiff(r,g,b,pix): if abs(r - pix[0]) &lt; 1 and abs(g - pix[1]) &lt; 1 and abs(b - pix[2]) &lt; 1: return False else: return Truedef isWhiteCenter(pix): if pix[0] == 245 and pix[1] == 245 and pix[2] ==245: return True else: return False def getDistance(dep,des): if des[0] &gt; dep[0]: x1,x2 = des[0],dep[0] else: x2,x1 = des[0],dep[0] x = (x1 - x2) y = (dep[1] - des[1])/2 dis = (x**2+y**2)**0.5 return disdef getTopPixel(pix,height,width,depPix): topPixel = [0,0] if depPix[0] &lt; width/2: startpoint = depPix[0] + 40 endpoint = width - 2 else: startpoint = 40 endpoint = depPix[0] - 40 deltaX = x0 = 0 flag = False for y in range(int(0.18 * height),int(0.66 * height)): for x in range(startpoint,endpoint): if x == startpoint: r, g, b = pix[x, y][0:3] elif isPixFuzzyDiff(r,g,b,pix[x,y]): r, g, b = pix[x, y][0:3] flag = not flag if not flag: break x0 = x elif flag : deltaX += 1 else: continue break print deltaX topPixel = [x0 + math.floor(deltaX)/2,y] return topPixel# button == buttom 懒得改def getButtonPixel(topPixel,pix): buttonPixel = [topPixel[0],0] r, g, b = pix[topPixel[0],topPixel[1]][0:3] for y in range(topPixel[1],topPixel[1] + 250): if not isPixAccurateDiff(r,g,b,pix[topPixel[0],y]): buttonPixel[1] = y return buttonPixeldef getdepPix(pix,height,width): depPix = [0,0] for y in range(1388,200,-1): for x in range(2,width-2): if isPixAccurateDiff(54,60,102,pix[x,y]): continue else: depPix = [x,y] break else: continue break return depPixdef main(): for i in range(20): filename = str(int(time.time())) + '.png' time.sleep(2) print "filename: " + filename time.sleep(2) os.system('adb shell /system/bin/screencap -p /sdcard/jump/' + filename) print "screencap" time.sleep(2) os.system('adb pull /sdcard/jump/' + filename + ' d:/MyCode/Python/jump/' + filename) print "pull"## filename = '1515321961' + '.png' im = Image.open(filename) pix = im.load() width = im.size[0] height = im.size[1] depPix = getdepPix(pix,height,width) topPixel = getTopPixel(pix,height,width,depPix) buttonPixel = getButtonPixel(topPixel,pix) desPix = [topPixel[0],(buttonPixel[1] - topPixel[1])/2 + topPixel[1]] print topPixel print buttonPixel print desPix print depPix dis = getDistance(depPix,desPix) print "distance: " + str(dis) swipeTime = 722/475.1 * dis print "swipeTime:" + str(swipeTime) os.system("adb shell input swipe 250 250 300 300 " + str(int(swipeTime))) if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda序列化问题]]></title>
    <url>%2F2017%2F12%2F12%2FLambda%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Lambda序列化问题这几天用spark遇到一个问题，到现在仍没有解决，不过查到了一些思路，可能与序列化有关。 先上代码1234567891011//不用Lambda，没有问题lines.mapToPair(new PairFunction&lt;String, Integer, Integer&gt;() &#123; private static final long serialVersionUID = 1323L; @Override public Tuple2&lt;Integer, Integer&gt; call(String word) throws Exception &#123; return new Tuple2&lt;Integer, Integer&gt;(1, 1); &#125; &#125;).take(200).forEach(v -&gt; System.out.println(v));//用lambda，报错lines.mapToPair(v -&gt; new Tuple2&lt;Integer, Integer&gt;(1, 1)).take(200).forEach(v -&gt; System.out.println(v)); 错误信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495017/12/12 16:00:53 WARN TaskSetManager: Lost task 0.0 in stage 1.0 (TID 1, 10.103.244.216): java.io.IOException: unexpected exception type at java.io.ObjectStreamClass.throwMiscException(ObjectStreamClass.java:1582) at java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1154) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2022) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2231) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2155) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2013) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2231) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2155) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2013) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2231) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2155) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2013) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2231) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2155) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2013) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:422) at org.apache.spark.serializer.JavaDeserializationStream.readObject(JavaSerializer.scala:76) at org.apache.spark.serializer.JavaSerializerInstance.deserialize(JavaSerializer.scala:115) at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:61) at org.apache.spark.scheduler.Task.run(Task.scala:89) at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:213) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)Caused by: java.lang.NoSuchMethodException: TestSUANZI.test.$deserializeLambda$(java.lang.invoke.SerializedLambda) at java.lang.Class.getDeclaredMethod(Class.java:2130) at java.lang.invoke.SerializedLambda$1.run(SerializedLambda.java:224) at java.lang.invoke.SerializedLambda$1.run(SerializedLambda.java:221) at java.security.AccessController.doPrivileged(Native Method) at java.lang.invoke.SerializedLambda.readResolve(SerializedLambda.java:221) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1148) ... 27 more17/12/12 16:00:53 INFO TaskSetManager: Starting task 0.1 in stage 1.0 (TID 2, 10.103.244.216, partition 0,ANY, 2193 bytes)17/12/12 16:00:53 INFO TaskSetManager: Lost task 0.1 in stage 1.0 (TID 2) on executor 10.103.244.216: java.io.IOException (unexpected exception type) [duplicate 1]17/12/12 16:00:53 INFO TaskSetManager: Starting task 0.2 in stage 1.0 (TID 3, 10.103.244.216, partition 0,ANY, 2193 bytes)17/12/12 16:00:53 INFO TaskSetManager: Lost task 0.2 in stage 1.0 (TID 3) on executor 10.103.244.216: java.io.IOException (unexpected exception type) [duplicate 2]17/12/12 16:00:53 INFO TaskSetManager: Starting task 0.3 in stage 1.0 (TID 4, 10.103.244.216, partition 0,ANY, 2193 bytes)17/12/12 16:00:53 INFO TaskSetManager: Lost task 0.3 in stage 1.0 (TID 4) on executor 10.103.244.216: java.io.IOException (unexpected exception type) [duplicate 3]17/12/12 16:00:53 ERROR TaskSetManager: Task 0 in stage 1.0 failed 4 times; aborting job 目前的解决方法是实现Serializable这个接口。 有时间读一下https://www.zhihu.com/question/51491241/answer/126232275]]></content>
      <categories>
        <category>Lambda表达式</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ScrapyDemo]]></title>
    <url>%2F2017%2F11%2F30%2FScrapyDemo%2F</url>
    <content type="text"><![CDATA[建立工程 scrapy startproject scrapydemo 目录分析 scrapy.cfg: 项目的配置文件 scrapytest/: 该项目的python模块。之后您将在此加入代码。 scrapytest/items.py: 项目中的item文件. scrapytest/pipelines.py: 项目中的pipelines文件. scrapytest/settings.py: 项目的设置文件. scrapytest/spiders/: 放置spider代码的目录. Tips1. spider name/spiders/目录下创建一个文件-name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。 2.多级抓取scrapy 在不同的抓取级别的Request之间传递参数的办法，下面的范例中，parse()通过meat传递给了parse_more()参数item，这样就可以再parse_more()抓取完成所有的数据后一次返123456789def parse(self, response): …… item['url'] = url.extract()[0] for item in items: yield Request(url = item['url'],meta = &#123;'item':item&#125;, callback = self.parse_more,dont_filter = True)def parse_more(self,response): item = response.meta['item'] …… yield item 总结需要修改demo的地方demo地址:https://github.com/CherryKeinz/ScrapyDemo 1. items.py修改类demoItem()里需要的字段 2. /spiders/MySpider.pyimport 要改为items.py中定义的类名from SpiderDemo.items import demoItem allowed_domains = [“http://10.3.210.84:4237/home/“]这个是 spider要求设置的一个变量,表示允许爬虫爬的网站 start_urls.append(url) url改为要爬的网址 如需保存为JSON，修改custom_settings 3.pipelines.py如需要，修改类JsonWithEncodingPipeline 常见错误 scrapy 报错 no module named win32api 的解决方案原因是缺少win32,到 http://sourceforge.net/projects/pywin32/files/找到对应的版本进行下载，直接安装即可]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo nexT的一些玩法（转载+总结）]]></title>
    <url>%2F2017%2F11%2F22%2FHexo-nexT%E7%8E%A9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基础篇1. 常用命令官方文档：https://hexo.io/zh-cn/docs/server.html 12345678hexo new &quot;HelloWorld&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo d #部署 #可与hexo g合并为 hexo d -g 2. 文章中插入图片对于hexo，有两种方式：使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。使用微博图床，地址 http://weibotuchuang.sinaapp.com/ ，将图片拖入区域中，会生成图片的URL，这就是链接地址。 3. 添加分页、标签页面新建命令： hexo new page tags # tags可替换成其他 输入命令后，在/source下会新生成一个新的文件夹tags，在该文件夹下会有一个index.md文件。在上步新生成的myBlog/source/tags/index.md中添加type: &quot;tags&quot;，index.md文件内容如下：设置具体文章的tags当要为某一篇文章添加标签，只需在/source/_post目录下的具体文章的tags中添加标签即可，如： tags: [hexo,next] 4. 引入第三方服务参考 : http://theme-next.iissnan.com/third-party-services.html#swfitype 1. 加入分享功能在主题配置文件中，jiathis: true 2. 加入评论功能 待续 3. 加入站点内容搜索功能 1) 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： $ npm install hexo-generator-searchdb --save 2) 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 3) 编辑 主题配置文件，启用本地搜索功能： 12local_search:enable: true 数据统计 5. 取消“文章目录”对标题的自动编号修改主题配置文件那里的toc:number为false 个性化 (参考)1. 修改文章内链接文本样式（待考证）修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 2. 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成/&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;/ 3. 在每篇文章末尾统一添加“本文结束”标记在路径\themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 4. 修改网页底部的桃心还是打开themes/next/layout/_partials/footer.swig，找到： 123&lt;span class="with-love"&gt; &lt;i class="fa fa-heart"&gt;&lt;/i&gt;&lt;/span&gt; 然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 5. 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，修改为 : 123456&lt;meta charset="UTF-8"/&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/&gt;&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;&lt;meta name="theme-color" content="&#123;&#123; theme.android_chrome_color &#125;&#125;"&gt; 参考资料：http://www.jianshu.com/p/c23902f93558http://blog.csdn.net/qq_33699981/article/details/72716951http://playingfingers.com/2016/03/26/build-a-blog/https://segmentfault.com/a/1190000003946969 5.添加网页音乐播放器功能Download Aplayer点击访问Aplayer源码：GitHub Aplayer。下载到本地，解压后将dist文件夹复制到themes\next\source文件夹下。 修改music.js新建themes\next\source\dist\music.js文件，添加内容： 12345678910111213141516171819202122232425262728293031const ap = new APlayer(&#123; container: document.getElementById(&apos;aplayer&apos;), fixed: true, autoplay: false, audio: [ &#123; name: &quot;canon in d&quot;, artist: &apos;Brian Crain&apos;, url: &apos;http://pd2tflnys.bkt.clouddn.com/Brian%20Crain%20-%20canon%20in%20d.mp3&apos;, cover: &apos;http://p1.music.126.net/QGb9Vtyw7qHS00uEvPfM6g==/843325418547559.jpg?param=130y130&apos;, &#125;, &#123; name: &quot;Apologize&quot;, artist: &apos;Martin Ermen&apos;, url: &apos;http://pd2tflnys.bkt.clouddn.com/Martin%20Ermen%20-%20Apologize.mp3&apos;, cover: &apos;http://p1.music.126.net/-_6mcI4VV5IKaiwhUAytbg==/1791104441647901.jpg?param=130y130&apos;, &#125;, &#123; name: &quot;River Flows in You&quot;, artist: &apos;Yiruma&apos;, url: &apos;http://pd2tflnys.bkt.clouddn.com/Yiruma%20-%20River%20Flows%20in%20You.flac&apos;, cover: &apos;http://p1.music.126.net/8ZRSyI0ZN_4ah8uzsNd1mA==/2324367581169008.jpg?param=130y130&apos;, &#125;, &#123; name: &apos;惊蛰&apos;, artist: &apos;音阙诗听/王梓钰&apos;, url: &apos;http://www.ytmp3.cn/down/48755.mp3&apos;, cover: &apos;http://p1.music.126.net/5MmXpaP9r88tNzExPGMI8Q==/109951163370350985.jpg?param=130y130&apos;, &#125; ]&#125;); 源码中对应的参数解释，这边都有： Aplayer 中文文档 audio对应的便是音频文件，所以音乐播放器需要播放的音乐是需要自己进行相关信息（如歌曲链接、歌词、封面等）的配置。这里放一个mp3音乐外链网站：http://up.mcyt.net/ ，搜索对应的音乐，然后复制url和右击封面图片链接粘贴到对应的位置上就行了。 注：由于该外链网站没有歌词链接，我这边没有进行配置，所以播放器在播放音乐时点击歌词是没有显示的。 _layout.swig打开themes\next\layout\_layout.swig文件，将 1234copy&lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/APlayer.min.css&quot;&gt;&lt;div id=&quot;aplayer&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/music.js&quot;&gt;&lt;/script&gt; 添加到&lt;body itemscope ...&gt;后面就行，即在&lt;body&gt;&lt;/body&gt;里面。 重新生成，访问页面，就能看到左下角的音乐播放器了。 6. 搞怪网页标题本章节参考 http://yearito.cn/posts/hexo-advanced-settings.html 1themes\next\layout\_custom\custom.swig 123456789101112131415161718&#123;# 搞怪网页标题 #&#125;&#123;% if theme.title_trick.enable %&#125; &lt;script&gt; var OriginTitile = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function() &#123; if (document.hidden) &#123; document.title = &apos;&#123;&#123; theme.title_trick.leave &#125;&#125;&apos; + OriginTitile; clearTimeout(titleTime); &#125; else &#123; document.title = &apos;&#123;&#123; theme.title_trick.enter &#125;&#125;&apos; + OriginTitile; titleTime = setTimeout(function() &#123; document.title = OriginTitile; &#125;, 2000); &#125; &#125;); &lt;/script&gt;&#123;% endif %&#125; 1themes\next\layout\_layout.swig 12345678 ... &#123;% include &apos;_third-party/exturl.swig&apos; %&#125; &#123;% include &apos;_third-party/bookmark.swig&apos; %&#125; &#123;% include &apos;_third-party/copy-code.swig&apos; %&#125;+ &#123;% include &apos;_custom/custom.swig&apos; %&#125; &lt;/body&gt; &lt;/html&gt; 在主题配置文件中添加以下代码： 12345# a trick on website titletitle_trick: enable: true leave: &quot;啊咧?真由氏的怀表停了呢~&quot; enter: &quot;这一切都是命运石之门的选择！&quot; 7. 豆瓣阅读 / 电影 / 游戏1npm install hexo-douban --save 核心配置文件_config.yml： 12345678910111213douban: user: # 个人豆瓣ID builtin: false #是否每次hexo d -g时都自动hexo douban book: title: &apos;This is my book title&apos; quote: &apos;This is my book quote&apos; movie: title: &apos;This is my movie title&apos; quote: &apos;This is my movie quote&apos; game: title: &apos;This is my game title&apos; quote: &apos;This is my game quote&apos; timeout: 10000 在主题配置文件themes\next\_config.yml中： 12345678menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || tasks+ books: /books/ || book + movies: /movies/ || video-camera + games: /games/ || gamepad 在语言包中新增菜单中文themes\next\language\zh_CN.yml： 12345678 menu: home: 首页 archives: 归档 categories: 分类 tags: 标签+ movies: 电影+ books: 读书+ games: 游戏]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
